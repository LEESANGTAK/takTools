//-
// =============================================================================
// Copyright 2024 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// =============================================================================

//+

/// \file  RuntimeServices.h
/// \brief RuntimeServices for operators.

#ifndef AMINO_CORE_RUNTIME_SERVICES_H
#define AMINO_CORE_RUNTIME_SERVICES_H

#include "CoreExport.h"

#include <Amino/Core/RuntimeMessageCategory.h>
#include <Amino/Core/StringView.h>

#include "internal/ConfigMacros.h"
#include "internal/Storage.h"

#include <type_traits>

//==============================================================================
// NAMESPACE Amino
//==============================================================================

namespace Amino {

// Forward declarations
class RuntimeMessage;
class RuntimeServices;
struct SdkStorage;

//==============================================================================
// CLASS RuntimeServices
//==============================================================================

/// \brief Runtime service that is used by operators.
///
/// \details The runtime service object is used by a job to capture messages
/// generated by its operators at runtime. Operators can call the logging
/// functions of the \ref RuntimeServices object to generate error, warning or
/// info messages. They can do so either by passing logging functions a functor
/// that will lazily be called only if logging is enabled for the given message
/// category, or by passing a \ref StringView directly. In the latter case,
/// except for \ref RuntimeServices::logError, it is up to the caller to ensure
/// that logging is enabled for the given category (logging messages when
/// logging is disabled will trigger an assertion).
///
/// The \ref RuntimeServices can also be used to profile the operator's
/// execution time by creating named profiling events.
///
/// Calls to all logging and profiling functions are thread-safe.
///
/// Operators requiring logging will specify the \ref RuntimeServices as a
/// parameter of its function after all regular inputs and outputs. The
/// RuntimeServices input can be annotated as a job port
/// (`AMINO_ANNOTATE("Amino::JobPort")`) like other job ports, but such
/// annotation is optional since \ref RuntimeServices can only be used as a job
/// port.
///
/// This \ref RuntimeServices parameter must be a const reference.
/// For example:
///
/// In header file:
/// \code{.cpp}
/// float average(
///     const FloatData& data,
///     RuntimeServices const& runtimeServices);
/// \endcode
///
/// In cpp file:
/// \code{.cpp}
/// float average(const FloatData& data, RuntimeServices const& runtimeServices)
/// {
///     using namespace Amino::StringViewLiterals;
///     size_t size = data.size();
///     if ( size == 0 ) {
///         runtimeServices.logError("No data to average!"_asv);
///     } else if ( size == 1 ) {
///         if (runtimeServices.isLogWarningEnabled())
///            runtimeServices.logWarning("Averaging a single value!"_asv);
///     } else {
///         runtimeServices.logInfo([size]() {
///             std::string msg = "Averaging ";
///             msg += std::to_string(size);
///             msg += " floats";
///             return msg;
///         });
///     }
///     // ...
/// }
/// \endcode
///
/// It is not necessary to specify the \ref RuntimeServices parameter on the
/// operator if logging/profiling is not required. The header parser will detect
/// the presence of the \ref RuntimeServices and generate the state required for
/// the operator to be called with this parameter.
///
/// \warning The \ref RuntimeServices mechanism must only be used to log runtime
/// messages and profiling events. It must never influence the output values of
/// an external operator. For example, the operator should always produce the
/// same output values, regardless if logging is enabled of not.
///
class RuntimeServices {
private:
    template <typename T, typename R = void>
    using enable_if_functor =
        std::enable_if_t<!std::is_convertible<T const&, StringView>::value, R>;

public:
    /*----- types -----*/

    using LogCallback = void (*)(
        RuntimeMessageCategory   category,
        Amino::StringView const& message,
        void*                    clientData);

    class ProfilerGuard;

    /*----- static member functions -----*/

    /// \brief Get reference to a "disabled" runtime services.
    ///
    /// This \ref RuntimeServices instance does not have logging enabled and has
    /// no profilers callbacks. It can be used by C++ library author to create
    /// operators that take a \ref RuntimeServices job port and want to write
    /// tests for such operators directly (without creating an Amino::Job
    /// that would pass said \ref RuntimeServices to the operator).
    static AMINO_CORE_SHARED_DECL RuntimeServices const& getDisabled();

    /*----- member functions -----*/

    /// \brief Constructs a \ref RuntimeServices that logs messages to the
    /// given output stream when messages are logged.
    /// \{
    template <typename OStream>
    explicit AMINO_INTERNAL_FORCEINLINE RuntimeServices(OStream* os)
        : RuntimeServices(os, RuntimeMessageCategory::kInfo) {}

    template <typename OStream>
    AMINO_INTERNAL_FORCEINLINE RuntimeServices(
        OStream* os, RuntimeMessageCategory logLevel)
        : RuntimeServices(&callback<OStream>, os, logLevel) {}
    /// \}

    /// \brief Constructs a \ref RuntimeServices that calls the given callback
    /// when messages are logged.
    AMINO_CORE_SHARED_DECL RuntimeServices(
        LogCallback            cb,
        void*                  clientData,
        RuntimeMessageCategory logLevel = RuntimeMessageCategory::kInfo,
        bool                   allowConcurrentCalls = false);

    /// \brief Copying and moving \ref RuntimeServices is prohibited.
    /// \{
    RuntimeServices(const RuntimeServices& rhs)                = delete;
    RuntimeServices(RuntimeServices&& rhs) noexcept            = delete;
    RuntimeServices& operator=(const RuntimeServices& rhs)     = delete;
    RuntimeServices& operator=(RuntimeServices&& rhs) noexcept = delete;
    /// \}

    /// \brief Destructor
    AMINO_CORE_SHARED_DECL ~RuntimeServices();

    /// \brief Check if logging is enabled for a specific category.
    AMINO_CORE_SHARED_DECL bool isLogEnabled(RuntimeMessageCategory cat) const;

    /// \brief Short-hand for isLogEnabled(RuntimeMessageCategory::kInfo)
    bool isLogInfoEnabled() const {
        return isLogEnabled(RuntimeMessageCategory::kInfo);
    }

    /// \brief Short-hand for isLogEnabled(RuntimeMessageCategory::kWarning)
    bool isLogWarningEnabled() const {
        return isLogEnabled(RuntimeMessageCategory::kWarning);
    }

    /// \brief Short-hand for isLogEnabled(RuntimeMessageCategory::kError)
    bool isLogErrorEnabled() const {
        return isLogEnabled(RuntimeMessageCategory::kError);
    }

    /// \brief Log a message with a specific category.
    ///
    /// \warning The message should only be generated if logging is enabled.
    ///
    /// Can either be called with a functor that generates the message which
    /// will be called only if logging is enabled, or with a \ref StringView
    /// (in which case it's up to the caller to ensure that logging is enabled
    /// with \ref isLogEnabled).
    /// \{
    template <typename MsgFunc>
    AMINO_INTERNAL_FORCEINLINE enable_if_functor<MsgFunc> //
    log(RuntimeMessageCategory category, MsgFunc const& msgFunc) const {
        using StringLike = std::remove_reference_t<decltype(msgFunc())>;
        static_assert(
            (std::is_constructible<StringView, StringLike const&>::value ||
             std::is_convertible<StringLike const&, StringView>::value),
            "msgFunc must return a type convertible to StringView");
        if (isLogEnabled(category)) {
            logImpl(category, msgFunc());
        }
    }
    void log(RuntimeMessageCategory category, StringView const& message) const {
        assert(isLogEnabled(category) && "Logging is disabled!");
        logImpl(category, message);
    }
    /// \}

    /// \brief Short-hand for log(RuntimeMessageCategory::kInfo, msg)
    template <typename Msg>
    AMINO_INTERNAL_FORCEINLINE void logInfo(Msg const& msg) const {
        log(RuntimeMessageCategory::kInfo, msg);
    }

    /// \brief Short-hand for log(RuntimeMessageCategory::kWarning, msg)
    template <typename Msg>
    AMINO_INTERNAL_FORCEINLINE void logWarning(Msg const& msg) const {
        log(RuntimeMessageCategory::kWarning, msg);
    }

    /// \brief Short-hand for log(RuntimeMessageCategory::kError, msg)
    template <typename Msg>
    AMINO_INTERNAL_FORCEINLINE enable_if_functor<Msg> logError(
        Msg const& msg) const {
        log(RuntimeMessageCategory::kError, msg);
    }

    /// \brief Log the given error message if logging of errors is enabled.
    ///
    /// \note Unlike the other log functions (which should only be called if
    /// logging is enabled), logError can be called unconditionally. If logging
    /// of error is disabled, it will just be a no-op. The reasonning for this
    /// exception is that typically logging of errors should always be enabled,
    /// but even if it's not, the performance hit of maybe creating a unused
    /// error message string is never a situation where performance would
    /// matter.
    AMINO_CORE_SHARED_DECL void logError(StringView msg) const;

    /// \brief Notify profiler about beginning of a new named event.
    /// \param eventName The name to associate with profiler event.
    /// \return Event ID which started a new profiling block.
    ///         This event should later be passed to profilerEventEnd
    ///         method in order to close profiling block.
    AMINO_CORE_SHARED_DECL int profilerEventBegin() const;

    /// \brief Notify profiler about beginning of a new named event.
    /// \param eventName The name to associate with profiler event.
    /// \return Event ID which started a new profiling block.
    ///         This event should later be passed to profilerEventEnd
    ///         method in order to close profiling block.
    AMINO_CORE_SHARED_DECL int profilerEventBegin(const char* eventName) const;

    /// \brief Notify profiler about end of an event.
    /// \param startEventID Link to an event ID which started profiling block.
    AMINO_CORE_SHARED_DECL void profilerEventEnd(int startEventID) const;

private:
    struct Private {};
    AMINO_CORE_SHARED_DECL explicit RuntimeServices(Private);

    /// \brief Callback function to log messages to the given output stream.
    template <typename OStream>
    static void callback(
        RuntimeMessageCategory   category,
        Amino::StringView const& message,
        void*                    clientData) {
        auto& os     = *static_cast<OStream*>(clientData);
        auto  prefix = getCategoryPrefix(category);
        os.write(prefix.data(), prefix.size());
        os.write(message.data(), message.size());
        os << '\n';
    }

    /// \brief Get the prefix string for a given category.
    ///
    /// Used by the output stream templated callback to write the category
    /// before the message.
    AMINO_CORE_SHARED_DECL static StringView getCategoryPrefix(
        RuntimeMessageCategory category);

    /// \brief Implementation of \ref log.
    /// \{
    AMINO_CORE_SHARED_DECL
    void logImpl(RuntimeMessageCategory cat, StringView message) const;

    template <typename StringLike>
    AMINO_INTERNAL_FORCEINLINE
        std::enable_if_t<!std::is_convertible<StringLike, StringView>::value>
        logImpl(RuntimeMessageCategory cat, StringLike&& message) const {
        return logImpl(cat, StringView{message});
    }
    /// \}

    friend SdkStorage;
    Internal::Storage_t<5> m_storage{};

public:
    /// \brief Deprecated functions.
    /// \{
    AMINO_INTERNAL_DEPRECATED(
        "SDK user should not construct RuntimeServices at all")
    explicit RuntimeServices(bool = false) : RuntimeServices{Private{}} {}

    AMINO_INTERNAL_DEPRECATED("Use log with a functor instead.")
    bool logEnabled() const {
        return isLogEnabled(RuntimeMessageCategory::kError);
    }

    AMINO_INTERNAL_DEPRECATED(
        "Use log/logInfo/logWarning/logError with a functor instead.")
    AMINO_CORE_SHARED_DECL void logMessage(RuntimeMessage const& message) const;
    /// \}
};

//==============================================================================
// CLASS RuntimeServices::ProfilerGuard
//==============================================================================

/// \brief Helper class to ensure all profiler events have matching begin/end
/// calls.
///
/// The ProfilerGuard begins the even upon construction and ends the event upon
/// destruction. It can be used like this:
///
/// \code{.cpp}
/// {
///     RuntimeServices::ProfilerGuard profGuard{runtimeServices, "my compute"};
///     // ...
/// }
/// // The guard is now out-of-scope, which will have called the destructor
/// // and therefore end the profiling event.
/// \endcode
///
/// \code{.cpp}
/// Which is equivalent to:
/// {
///     int eventId = runtimeServices.profilerEventBegin("my compute");
///     // ...
///     runtimeServices.profilerEventEnd(eventId);
/// }
/// \endcode
class RuntimeServices::ProfilerGuard {
public:
    /// \brief Constructor
    ///
    /// Starts the profiling event.
    /// \{
    ProfilerGuard(RuntimeServices const& rs, const char* eventName)
        : m_rs(rs), m_id(rs.profilerEventBegin(eventName)) {}
    explicit ProfilerGuard(RuntimeServices const& rs)
        : m_rs(rs), m_id(rs.profilerEventBegin()) {}
    /// \}

    /// \brief Destructor
    ///
    /// Ends the profiling event.
    ~ProfilerGuard() { m_rs.profilerEventEnd(m_id); } // LCOV_EXCL_BR_LINE

private:
    RuntimeServices const& m_rs;
    int                    m_id;
};
} // namespace Amino

#endif // AMINO_CORE_RUNTIME_SERVICES_H
