// ===========================================================================
// Copyright 2019 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Creation Date:  Dec 3, 1996
//
//
//  Description:
//      This script describes the contents of the context sensitive menus.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

global proc maintainActiveChangeSelectMode( string $item, int $defaultItem )
{
	string $items[]; $items[`size $items`] = $item;
	string $hlItem[] = `ls -hilite $item`;

	// MAYA-67156: If object under the the cursor is not selected or highlighted
	// then use the existing hilite list. (see buildObjectMenuItemsNow.mel)
	if ($defaultItem || (size($hlItem) == 0 && size(`ls -sl $item`) == 0)) {
		string $objects[] = `ls -hl -typ transform -typ shape`;
		if (size($objects) > 0) {
			string $newItem[] = `ls -hilite $objects`;
			if (size($newItem) > 0) {
				$hlItem = $newItem;
				$items = $objects;
			}
		}
	}

	// Unhilite related objects
	string $unhiliteList[] = `listRelatives -fullPath -shapes $items`;
	appendStringArray($unhiliteList, $items, size($items));
	hilite -unHilite $unhiliteList;

	// Switch to object mode (without affecting the current selection)
	int $aa = `selectPref -q -affectsActive`;
	if (1 == $aa)
		selectPref -affectsActive 0;

	changeSelectMode -object;

	if (1 == $aa)
		selectPref -affectsActive 1;

	// Select previously highlighted item
	if (size($hlItem) > 0)
		select -add $items;

	// Switch out of show manip tool
	HideManipulators;
}

proc optionalDagMenuProc( string $parent, string $item )
{
	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;

	string $shape = "";
	int $gotVisible = 0;

	if( size($object) < 1 ) return;

	for( $i=0; $i<size($object); $i+=1) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for( $i=0; $i<size($object); $i+=1) {
			if( 0 == getAttr($object[$i] + ".io")) {
				$shape = $object[$i];
				break;
			}
		}
	}

	if( "" != $shape ) {
		string $nt = `nodeType $shape`;
		switch( $nt ) {
		  case "subdiv":
			subdOptionalDagMenuProc( $parent, $item );
			menuItem -d true;
			break;

		  default:
			// Check to make sure we have a kPlugin prefix
			string $apiNt = `nodeType -api $shape`;
			if ( startsWith( $apiNt, "kPlugin" ) ) {
				string $nodeMenuCommand = $nt + "DagMenuProc";
				string $nodeMenuCommandWithArgs = $nodeMenuCommand + "(\"" + $parent + "\" , \"" + $item + "\" )";
				if ( exists( $nodeMenuCommand ) ) {
				   eval( $nodeMenuCommandWithArgs );
				}
			}
			break;
		}
	}
}

proc int objectIsTrimmed(string $item)
// Return true if this is a trimmed surface
{
	string $command = ("getAttr -size " + $item + ".trimFace");
	int $trimCount = eval($command);

	return ($trimCount != 0);
}


// returns true if item was added to quadrant
proc int checkForSkinInfluenceItem(string $item, string $quadrant)
{
    int $quadFilled = 0;
	int $isJoint = (nodeType($item) == "joint");

	// Check if the current context is the skinPaint context
	// and the the joint is connected to a skinCluster
	//
	string  $currContext = `currentCtx`;

	string  $currTool    = "";
	if(`contextInfo -ex $currContext`)
		$currTool = `contextInfo -c $currContext`;

	string $paintWeights = (uiRes("m_dagMenuProc.kPaintWeights"));
	if ( $currTool == "artAttrSkin" ) {
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "skinWeights" )  {
			string $connL[] = `listConnections ($item+".worldMatrix")`;
			string $conn;
			for($conn in $connL) {
				if (`nodeType $conn` == "skinCluster")
				{
					// select the surface (not the joint) and set
					// the joint as the current influence
					//
					string $currSel[] = `ls -sl`;
					string $currSelString;
					if (size($currSel) > 0) {
						string $currObj;
						$currSelString = "select -r ";
						for ($currObj in $currSel) {
							$currSelString += ($currObj+" ");
						}
					}
					menuItem -label $paintWeights
						-echoCommand true
						-c ($currSelString+"; setSmoothSkinInfluence " + $item)
						-rp $quadrant
						paintWeightItem;
                    $quadFilled = 1;
					break;
				}
			}
		}
	}

	// menu for skinCluster paint
	// Check if the current context is the clusterPaint context
	// and the the joint is connected to a jointCluster
	//
	else if ( $isJoint && ($currTool == "artAttr") ) {
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "general" )  {
			string $connL[] = `listConnections ($item+".worldMatrix")`;
			string $conn;
			for($conn in $connL) {
				if (`nodeType $conn` == "jointCluster")
				{
					string $artCommand = "artAttrCtx" ;
					string $attribute = "cluster." + $conn +  ".weights" ;
					menuItem -label $paintWeights
						-echoCommand true
						// the following command doesnot update the UI hence we use the next one
						//-c ("artAttrCtx -e -pas \"cluster." + $conn +  ".weights\" `currentCtx`")
						-c ("artSetToolAndSelectAttr( \"" + $artCommand + "\", \"" + $attribute + "\" )")
						-rp "N"
						paintWeightItem;
					break;
				}
			}
		}
	}
	// menu for joint-set paint
	// Check if the current context is the setPaint context
	// and the the joint is connected to a objectSet via jointCluster
	//
	else if ( $isJoint && ($currTool == "artSetPaint") ) {
		string $connL[] = `listConnections ($item+".worldMatrix")`;
		string $conn;
		for($conn in $connL) {
			if (`nodeType $conn` == "jointCluster") {
				string $connS[] = `listConnections ($conn+".message")`;
				for($set in $connS) {
					if (`nodeType $set` == "objectSet") {
						menuItem -label (uiRes("m_dagMenuProc.kPaintSetMembership"))
							-echoCommand true
							// the following command doesnot update the UI hence we use the next one
							//-c ("artSetPaintCtx -e -settomodify " + $set + " `currentCtx`")
							-c ("artSetPaintSelectSet( \"" + $set + "\" )")
							-rp "N"
							paintWeightItem;
						break;
					}
				}
			}
		}
	}
    return $quadFilled;
}

global proc string[] objectSelectMasks(string $item)
// Returns the component selection masks that apply to this object
{
	string $maskList[];
	string $shape = $item;
	int $i;

	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;

	int $gotVisible = 0;

	for ($i = 0; $i < size($object); ++$i) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for ($i = 0; $i < size($object); ++$i)
		{
			if (getAttr($object[$i] + ".io") == 0)
			{
				$shape = $object[$i];
				break;
			}
		}
	}

	string $nt = `nodeType $shape`;

	switch ($nt) {
		case "lattice":
			$maskList[0] = "latticePoint";
			break;
		case "locator":
			$maskList[0] = "locator";
			break;
		case "nurbsCurve":
			$maskList[0] = "curveParameterPoint";
			$maskList[1] = "controlVertex";
			$maskList[2] = "editPoint";
			$maskList[3] = "hull";
			break;
		case "bezierCurve":
			$maskList[0] = "curveParameterPoint";
			$maskList[1] = "bezierAnchor";
			$maskList[2] = "editPoint";
			$maskList[3] = "hull";
			break;
		case "nurbsSurface":
			$maskList[0] = "isoparm";
			$maskList[1] = "controlVertex";
			$maskList[2] = "surfaceParameterPoint";
			$maskList[3] = "hull";
			$maskList[4] = "surfaceFace";
			$maskList[5] = "surfaceUV";
			if (objectIsTrimmed($shape)) {
				$maskList[6] = "surfaceEdge";
			}
			break;
		case "mesh":
			$maskList[0] = "edge";
			$maskList[1] = "vertex";
			$maskList[2] = "facet";
			$maskList[3] = "puv";
			$maskList[4] = "pvf";
			$maskList[5] = "meshComponents";
			break;
		case "joint":
		case "hikFKJoint":
			$maskList[0] = "joint";		// special case
			break;
		case "ikHandle":
			$maskList[0] = "ikHandle";	// special case
			break;
		case "hikEffector":
		case "hikIKEffector":
		// fall through
		case "hikFloorContactMarker":
			$maskList[0] = "hikEffector";	// special case
			break;
		case "motionTrailShape":
			$maskList[0] = "motionTrail";
			break;
		case "particle":
			$maskList[0] = "particle";	// only one choice
			break;
		case "nParticle":
			$maskList[0] = "particle";	// only one choice
			break;
		case "spring":
			$maskList[0] = "springComponent";	// only one choice
			break;
		case "subdiv":
 			$maskList[0] = "subdivMeshPoint";
 			$maskList[1] = "subdivMeshEdge";
 			$maskList[2] = "subdivMeshFace";
 			$maskList[3] = "subdivMeshUV";
			break;
	}

	return $maskList;
}


global proc string dagMenuProc_selectionMask_melToUI( string $mel )
{
	string $result = $mel;

	switch ($mel)
	{
		case "latticePoint":
			$result = (uiRes("m_dagMenuProc.kLatticePoint"));
			break;
		case "locator":
			$result = (uiRes("m_dagMenuProc.kLocator"));
			break;
		case "bezierAnchor":
			$result = (uiRes("m_dagMenuProc.kBezierAnchor"));
			break;
		case "controlVertex":
			$result = (uiRes("m_dagMenuProc.kControlVertex"));
			break;
		case "editPoint":
			$result = (uiRes("m_dagMenuProc.kEditPoint"));
			break;
		case "hull":
			$result = (uiRes("m_dagMenuProc.kHull"));
			break;
		case "isoparm":
			$result = (uiRes("m_dagMenuProc.kIsoparm"));
			break;
		case "subdivMeshEdge":
			// fall through
		case "edge":
			$result = (uiRes("m_dagMenuProc.kEdge"));
			break;
		case "subdivMeshPoint":
			// fall through
		case "vertex":
			$result = (uiRes("m_dagMenuProc.kVertex"));
			break;
		case "joint":
			$result = (uiRes("m_dagMenuProc.kJoint"));
			break;
		case "ikHandle":
			$result = (uiRes("m_dagMenuProc.kIkHandle"));
			break;
		case "hikEffector":
			$result = (uiRes("m_dagMenuProc.kHikEffector"));
			break;
		case "motionTrail":
			$result = (uiRes("m_dagMenuProc.kMotionTrail"));
			break;
		case "ikfkHandle":
			$result = (uiRes("m_dagMenuProc.kIkfkHandle"));
			break;
		case "surfaceUV":
			$result = (uiRes("m_dagMenuProc.kSurfaceUV"));
			break;
		case "surfaceParameterPoint":
			$result = (uiRes("m_dagMenuProc.kSurfacePoint"));
			break;
		case "curveParameterPoint":
			$result = (uiRes("m_dagMenuProc.kCurvePoint"));
			break;
		case "surfaceEdge":
			$result = (uiRes("m_dagMenuProc.kTrimEdge"));
			break;
		case "surfaceFace":
			$result = (uiRes("m_dagMenuProc.kSurfacePatch"));
			break;
		case "subdivMeshUV":
			// fall through
		case "puv":
			$result = (uiRes("m_dagMenuProc.kUV"));
			break;
		case "subdivMeshFace":
			// fall through
		case "facet":
			$result = (uiRes("m_dagMenuProc.kFace"));
			break;
		case "pvf":
			$result = (uiRes("m_dagMenuProc.kVertexFace"));
			break;
		case "nParticle":
		case "particle":
			$result = (uiRes("m_dagMenuProc.kParticle"));
			break;
		case "springComponent":
			$result = (uiRes("m_dagMenuProc.kSpring"));
			break;
		case "meshComponents":
			$result = (uiRes("m_dagMenuProc.kMultiComp"));
			break;
		default:
			uiToMelMsg( "dagMenuProc_selectionMask_melToUI", $mel, 1 );
			break;
	}

	return $result;
}

global proc int isRadialPositionUsed(string $radialPositionUsed[],string $position)
{
    for($pos in $radialPositionUsed)
    {
        if($pos == $position)
            return 1;
    }
    return 0;
}

global proc populateMMForPaintSkinWeights(string $item,string $radialPositionUsed[])
{
    // Check if the current context is the skinPaint context
	// and the the joint is connected to a skinCluster
	//

	string  $currContext = `currentCtx`;
	if ( $currContext == "artAttrSkinContext" )
	{
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "skinWeights" )
		{

			if (`attributeQuery -n $item -ex liw`)
		    {

			    menuItem -l (uiRes("m_dagMenuProc.kPaintPickValue"))
				    -echoCommand true
				    -c "artAttrCtx -e -pickValue `currentCtx`"
				    -rp "S";

			    $radialPositionUsed[size($radialPositionUsed)] = "S";

		        string $cmd = "artSkinLockInfPassedIn " + $item + " ";
		        if ( `getAttr ( $item + ".liw" )` == 0 )
			    {
			        $cmd += "1";
				    menuItem -l (uiRes("m_dagMenuProc.kDagMenuLockInfluence"))
					    -echoCommand true
					    -c $cmd
					    -rp "NW";
			    }
			    else
			    {
			        $cmd += "0";
				    menuItem -l (uiRes("m_dagMenuProc.kDagMenuUnlockInfluence"))
					    -echoCommand true
					    -c $cmd
					    -rp "NW";
			    }
			    $radialPositionUsed[size($radialPositionUsed)] = "NW";

			    if ( `getAttr ($item + ".displayHandle")` == 0)
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kShowDisplayHandle"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayHandle 1" )
					    -rp "W";
			    }
			    else
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kHideDisplayHandle"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayHandle 0" )
					    -rp "W";
			    }

			    $radialPositionUsed[size($radialPositionUsed)] = "W";

			    if ( `getAttr ( $item + ".displayLocalAxis" )` == 0 )
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kDisplayLocalAxis"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayLocalAxis 1" )
					    -rp "SW";
			    }
			    else
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kHideLocalAxis"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayLocalAxis 0" )
					    -rp "SW";
			    }
			    $radialPositionUsed[size($radialPositionUsed)] = "SW";

                string $selectVertCmd;

                $selectVertCmd = "artSkinSelectVerticesForInfluence " + $item + " 0 0 ";

			    menuItem -l (uiRes("m_dagMenuProc.kSelectAffectedVertices"))
				    -echoCommand true
				    -c $selectVertCmd
				    -rp "NE";

			    $radialPositionUsed[size($radialPositionUsed)] = "NE";

                string $addSelectedVerticesCmd = "artSkinSelectVerticesForInfluence " + $item + " 1 0";
			    menuItem -l (uiRes("m_dagMenuProc.kAddSelectedVertices"))
				    -echoCommand true
				    -c $addSelectedVerticesCmd
				    -rp "E";

			    $radialPositionUsed[size($radialPositionUsed)] = "E";

                string $removeSelectedVerticesCmd = "artSkinSelectVerticesForInfluence " + $item + " 0 1";
			    menuItem -l (uiRes("m_dagMenuProc.kDeselectAffectedVertices"))
				    -echoCommand true
				    -c $removeSelectedVerticesCmd
				    -rp "SE";

			    $radialPositionUsed[size($radialPositionUsed)] = "SE";

		        string $selectCmd = "setSmoothSkinInfluence " + $item + ";";
		        $selectCmd += "artSkinRevealSelected artAttrSkinPaintCtx";
		        menuItem -l (uiRes("m_dagMenuProc.kSelectInfluence"))
				-echoCommand true
				-c $selectCmd
				-rp "N";

				$radialPositionUsed[size($radialPositionUsed)] = "N";
			}
			else
			{

			    string $setPaintModeCmd = "artAttrSkinSetPaintMode 1";
			    menuItem -l (uiRes("m_dagMenuProc.kSetPaintMode"))
				    -echoCommand true
				    -c $setPaintModeCmd
				    -rp "NW";

			    $radialPositionUsed[size($radialPositionUsed)] = "NW";

			    string $setSelectModeCmd = "artAttrSkinSetPaintMode 0";
			    menuItem -l (uiRes("m_dagMenuProc.kSetSelectMode"))
				    -echoCommand true
				    -c $setSelectModeCmd
				    -rp "E";

			    $radialPositionUsed[size($radialPositionUsed)] = "E";

                string $setPaintSelectModeCmd = "artAttrSkinSetPaintMode 2";
			    menuItem -l (uiRes("m_dagMenuProc.kSetPaintSelectMode"))
				    -echoCommand true
				    -c $setPaintSelectModeCmd
				    -rp "SE";

			    $radialPositionUsed[size($radialPositionUsed)] = "SE";
			}
		}
	}
}

global proc paintSkinWeightsChangeSelectMode( string $item )
{
	python("import maya.app.general.artAttrSkinUtils; maya.app.general.artAttrSkinUtils.marking_menu_change_select_mode('"+ $item + "')");
}


global proc createSelectMenuItems(string $parent, string $item, int $defaultItem)
// Create a menu that shows the dag parenting for this object
{
	string $maskList[] = `objectSelectMasks($item)`;

	string $radialPosition[];
	string $uiName;

	int $i;
	int $isNurbObject     = false;
	int $isBezierObject   = false;
	int $isPolyObject     = false;
	int $isLatticeObject  = false;
	int $isJointObject    = false;
	int $isHikEffector	  = false;
	int $isIkHandleObject = false;
	int $isIkFkHandleObject = false;
	int $isParticleObject = false;
	int $isSpringObject   = false;
	int $isSubdivObject   = false;
	int $isLocatorObject  = false;
	int $hasComponents	  = false;
	int $isMotionTrail    = false;

	//	Comparing an element in an empty array will increase the array
	//	to accomodate that element.
	//
	//	To avoid this, first test the size of the array before comparing
	//	elements that may not exist.
	//
	if (1 <= size($maskList)) {
		$isLatticeObject = ($maskList[0] == "latticePoint");
		$isJointObject = ($maskList[0] == "joint");
		$isHikEffector = ($maskList[0] == "hikEffector");
		$isIkHandleObject = ($maskList[0] == "ikHandle");
		$isParticleObject = ($maskList[0] == "particle");
		$isSpringObject = ($maskList[0] == "springComponent");
		$isSubdivObject = ($maskList[0] == "subdivMeshPoint");
		$isLocatorObject = ($maskList[0] == "locator");
		$isMotionTrail = ($maskList[0] == "motionTrail");
	}
	if (2 <= size($maskList)) {
		$isBezierObject = ($maskList[1] == "bezierAnchor");
		$isNurbObject = ($maskList[1] == "controlVertex");
		$isPolyObject = ($maskList[1] == "vertex");
	}

	// $maxRadialPos keeps track of how many octants of the
	// RMB marking menu will be populated
	//
	int $maskSize = size($maskList);
	int $maxRadialPos = size($maskList);

	$hasComponents = $isLatticeObject ||
					 $isParticleObject ||
					 $isSubdivObject ||
					 $isSpringObject ||
					 $isNurbObject ||
					 $isPolyObject ||
					 $isBezierObject;

	// NOTE:
	//			If the object has selectable components, then the
	//		radial position "NE" will be used for the menuItem:
	//		"Revert back to object mode."
	//
	setParent -menu $parent;
	$radialPosition[0] = "N";
	$radialPosition[1] = "W";
	$radialPosition[2] = "S";
	$radialPosition[3] = "E";
	$radialPosition[4] = "SW";
	$radialPosition[5] = "SE";
	$radialPosition[6] = "NW";
	$radialPosition[7] = "NE";

	string $radialPositionUsed[];

    string $disableikHandle = (uiRes("m_dagMenuProc.kDisableIkHandle"));
    string $enableIkHandle  = (uiRes("m_dagMenuProc.kEnableIkHandle"));
	string $setPreferred	= (uiRes("m_dagMenuProc.kSetPreferredAngle"));
	string $assumePreferred = (uiRes("m_dagMenuProc.kAssumePreferredAngle"));

	if ($isJointObject) {
		string $setCmd = `performSetPrefAngle 2`;
		string $assumeCmd = `performAssumePrefAngle 2`;
		$setCmd += (" "+$item);
		$assumeCmd += (" "+$item);
		string $jts[] = `ls -sl -type joint`;
		for ($jointItem in $jts) {
			if ($jointItem != $item) {
				$setCmd += (" "+$jointItem);
				$assumeCmd += (" "+$jointItem);
			}
		}

	    string  $currContext = `currentCtx`;

		string  $currTool = "";
		if (`contextInfo -ex $currContext`)
			$currTool = `contextInfo -c $currContext`;

	    if ( $currTool != "artAttrSkin" )
	    {
		    string $hikHandle[] = `listConnections -type hikHandle $item`;
		    int $isFBIKjoint = (size($hikHandle) > 0);
			int $isHIKjoint = `objectType -isa hikFKJoint $item`;
		    if ($isFBIKjoint || $isHIKjoint) {
				string $reachLocation = "S";
				if ($isHIKjoint) {
					$reachLocation = "N";
				}
			    createFBIKmenuItems($parent, $item, $isFBIKjoint,
									$reachLocation,"E","NE","SE");
			} else {
				string $setPreferredQuad = "W";
				string $assumePreferredQuad = "E";
				string $bones[] = `ls -sl -type "joint"`;
				if($item != "")
				{
					$bones[size($bones)] = $item;
				}
				int $showbs = 0;
				for($bone in $bones)
				{
					string $connected[] = `listConnections ($bone + ".jointOrient")`;
					for($symmetryC in $connected)
					{
    					if(`nodeType $symmetryC` == "symmetryConstraint")
						{
							$showbs = 1;
							break;
						}
					}
				}

    			string $breakSymmetryCmd = "string $bones[] = `ls -sl -type \"joint\"`; ";
				if($item != "")
				{
					$breakSymmetryCmd += "$bones[size($bones)] = \"" + $item + "\";";
				}
				$breakSymmetryCmd += "breakSymmetry($bones);";
				if (isComponentSelected()) {
					menuItem -label ("Set weight 0.0 for \""+$item+"\"")
						-echoCommand true
						-c ("setSkinWeightSelect(\""+$item+"\", 0.0)")
						-rp "W"
						set0WeightItem;
					menuItem -label ("Set weight 1.0 for \""+$item+"\"")
						-echoCommand true
						-c ("setSkinWeightSelect(\""+$item+"\", 1.0)")
						-rp "E"
						set1WeightItem;
				}
			}
	    }
	    else
	    {
	        populateMMForPaintSkinWeights($item,$radialPositionUsed);
	    }


	} else {
		for ($i = 0; $i < size($maskList); $i++) {
			if ($maskList[$i] == "ikfkHandle") {
				continue;
			}

			$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			menuItem -label $uiName
				-ecr false
				-c ( "doMenuComponentSelection(\"" +
					$item + "\", \"" +  $maskList[$i] + "\")")
				-rp $radialPosition[$i];
		}
	}

	// If components are present, provide the ability to
	// get back to object mode...
	//
	if ($hasComponents) {
		menuItem -label (uiRes("m_dagMenuProc.kObjectMode"))
				-ecr false
				-c ("maintainActiveChangeSelectMode " + $item + " " + $defaultItem + ";")
				-rp "NE";
				if( hasTraversalMM() ){
					string $dgDagMenu = `menuItem -subMenu true -rp "NW"
							-image "move_M"
							-label (uiRes("m_dagMenuProc.kDGDagTraversal"))`;
					menuItem -e -pmc ("setParent -m " + $dgDagMenu + ";buildTraversalMM \"" + $item + "\";") $dgDagMenu;
					setParent -menu ..;
				}
	}

	// Since any object can be an ikfk handle, we only populate the ikfk items
	// in slots that are not already in use.
	//
	if ($isIkFkHandleObject) {
		string $handle = getControlledHandle($item);

		if ($maxRadialPos < 8) {
			menuItem -label (uiRes("m_dagMenuProc.kSetIKFKKey"))
				-echoCommand true
				-annotation (uiRes("m_dagMenuProc.kSetKeysAnnot"))
				-rp $radialPosition[7]
				-command ("select -r "+$item+"; SetIKFKKeyframe");
		}

		if ($maxRadialPos < 7) {
			menuItem -label (uiRes("m_dagMenuProc.kMoveIKToFK"))
				-echoCommand true
				-annotation (uiRes("m_dagMenuProc.kSelectAnIKHandleOrIKFKAnnot"))
				-rp $radialPosition[6]
				-command ("select -r "+$item+"; MoveIKtoFK");
		}

		if ($maxRadialPos < 5) {
			menuItem -label $disableikHandle
				-annotation (uiRes("m_dagMenuProc.kDisableIKHandleAnnot"))
				-echoCommand true
				-c ("ikHandle -e -dh " + $handle)
				-rp $radialPosition[5];

			menuItem -label $enableIkHandle
				-annotation (uiRes("m_dagMenuProc.kEnableIKHandleAnnot"))
				-echoCommand true
				-c ("ikHandle -e -eh " + $handle)
				-rp $radialPosition[4];
		}
	}

//	for ($i = 0; $i < size($maskList); $i++) {
//       $itemName = "SELM" + string($i);
//			setParent -menu $parent;
//			menuItem
//				-c ("doMenuComponentSelection(\"" +
//					$item + "\", \"" +  $maskList[$i] + "\")")
//				-label $maskList[$i]
//				-rp $radialPosition[$i]
//				$itemName;
//	}
	setParent -menu $parent;
}

global proc doMenuComponentSelectionExt(string $item, string $mask, int $defaultItem)
{
	string $selectCmd;

	string $items[]; $items[`size $items`] = $item;
	string $hlItem[] = `ls -hl $item`;

	// MAYA-67156: If no object is under the the cursor then use the existing
	// selection/hilite list. (see buildObjectMenuItemsNow.mel)
	if ($defaultItem) {
		string $objects[] = `ls -sl -typ transform -typ shape`;
		if (size($objects) == 0) {
			$objects = `ls -hl -typ transform -typ shape`;
		}
		if (size($objects) > 0) {
			$items = $objects;
		}
	}

	if (`selectMode -q -object`) {
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true; selectType -" + $mask + " true; hilite ";
		for ($currItem in $items)
			$selectCmd += " " + $currItem;
		$selectCmd += ";";
	} else {
		selectType -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (!`selectMode -q -preset`) {
			$selectCmd += " hilite";
			for ($currItem in $items)
				$selectCmd += " " + $currItem;
			$selectCmd += ";";
		}
	}
	HideManipulators;
	eval $selectCmd;
	if(`exists dR_selTypeChanged`) { dR_selTypeChanged($mask); }
}

global proc doMenuComponentSelection(string $item, string $mask)
//
// Changes the selection/display state on this object to allow
// selection of the specified selection mask type.
{
	doMenuComponentSelectionExt($item, $mask, 0);
}

global proc undoMenuComponentSelection(string $item, string $mask)
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		$selectCmd = "selectType -ocm -" + $mask + " false; selectType -" + $mask + " false;";
	} else {
		$selectCmd = "selectType -" + $mask + " false;";
	}

	eval $selectCmd;
}

global proc getActiveModelPanel()
{
	string $activePanel = `getPanel -wf`;
	int $match = `gmatch $activePanel "modelPanel*"`;
	if($match == 1)
	{
		int $currentIsolateValue = `isolateSelect -q -state $activePanel`;
		if($currentIsolateValue == 0)
		{
			enableIsolateSelect $activePanel 1;
			isolateSelect -state 1 $activePanel;
		}
		else
		{
			enableIsolateSelect $activePanel 0;
			isolateSelect -state 0 $activePanel;
		}
	}
}

proc setUpArtisanSkinContext(string $parent, string $object)
{
	createSelectMenuItems($parent, $object, 0);

	string $shortName = `substitute ".*|" $object ""`;
	menuItem -label ($shortName + "...") -c ("showEditor "+$object);
	menuItem -divider true;
	menuItem -divider true;

	menuItem -divider true;
	menuItem -divider true;

	menuItem -label (uiRes("m_dagMenuProc.kDagMenuGotoBindPose")) -c "gotoBindPose";

	menuItem -divider true;
	menuItem -divider true;

	menuItem -label (uiRes("m_dagMenuProc.kDagMenuSelect"))  -c ("select -r " + $object);
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuAddToSelection")) -c ("select -add " + $object);
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuSelectHierarchy"))  -c ("select -hierarchy " + $object);

	menuItem -divider true;
	menuItem -divider true;

	string $activePanel = `getPanel -wf`;
	int $currentXrayValue = `modelEditor -q -jointXray $activePanel`;
	$xrayJointCB = `menuItem -subMenu false -cb $currentXrayValue  -c "skinPaintXrayJoints;" -label (uiRes("m_dagMenuProc.kDagMenuXRayJoints")) xrayJointsCB`;
	setParent -m $parent;

	int $currentIsolateValue = `isolateSelect -q -state $activePanel`;
	$isolateParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuIsolate"))`;
	menuItem -subMenu false -cb $currentIsolateValue  -c "getActiveModelPanel;" -label (uiRes("m_dagMenuProc.kDagMenuIsolateSelected")) $isolateParent;
	menuItem -subMenu false -label (uiRes("m_dagMenuProc.kDagMenuAddObject")) -c "addSelectedToIsolation;" $isolateParent;
	setParent -m $parent;

	menuItem -divider true;
	menuItem -divider true;

	int $artAttrUseColorRamp = `artAttrCtx -q -useColorRamp artAttrSkinContext`;
	$colorRampCB = `menuItem -subMenu false -cb $artAttrUseColorRamp  -c "skinPaintUseColorFeedback;" -label (uiRes("m_dagMenuProc.kDagMenuUseColorRamp")) useColorFeedbackCB`;

	$paintModeParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuPaintMode")) $parent`;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeAdd")) -c "artAttrPaintOperation artAttrSkinPaintCtx Add;" $paintModeParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeReplace")) -c "artAttrPaintOperation artAttrSkinPaintCtx Replace;" $paintModeParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeScale")) -c "artAttrPaintOperation artAttrSkinPaintCtx Scale;" $paintModeParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeSmooth")) -c "artAttrPaintOperation artAttrSkinPaintCtx Smooth;" $paintModeParent;

	setParent -m $parent;


	$brushParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuBrushProfile")) $parent`;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushProfileHard")) $brushParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushProfileSoft")) $brushParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushProfileGaussian")) $brushParent;

	setParent -m $parent;

	$valueParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuBrushValue")) $parent`;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue0")) -c "artSkinSetSelectionValue 0.000 false artAttrSkinPaintCtx artAttrSkin;" $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue1")) -c "artSkinSetSelectionValue 0.100 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue2")) -c "artSkinSetSelectionValue 0.200 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue3")) -c "artSkinSetSelectionValue 0.300 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue4")) -c "artSkinSetSelectionValue 0.400 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue5")) -c "artSkinSetSelectionValue 0.500 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue6")) -c "artSkinSetSelectionValue 0.600 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue7")) -c "artSkinSetSelectionValue 0.700 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue8")) -c "artSkinSetSelectionValue 0.800 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue9")) -c "artSkinSetSelectionValue 0.900 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue10")) -c "artSkinSetSelectionValue 1.000 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;

	setParent -m $parent;

	$opacityParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuOpacity")) $parent`;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue0")) -c "artAttrSkinPaintCtx -e -opacity 0.000 `currentCtx`" $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue1")) -c "artAttrSkinPaintCtx -e -opacity 0.100 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue2")) -c "artAttrSkinPaintCtx -e -opacity 0.200 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue3")) -c "artAttrSkinPaintCtx -e -opacity 0.300 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue4")) -c "artAttrSkinPaintCtx -e -opacity 0.400 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue5")) -c "artAttrSkinPaintCtx -e -opacity 0.500 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue6")) -c "artAttrSkinPaintCtx -e -opacity 0.600 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue7")) -c "artAttrSkinPaintCtx -e -opacity 0.650 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue8")) -c "artAttrSkinPaintCtx -e -opacity 0.750 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue9")) -c "artAttrSkinPaintCtx -e -opacity 0.850 `currentCtx`"  $opacityParent;
	menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue10")) -c "artAttrSkinPaintCtx -e -opacity 1.000 `currentCtx`"  $opacityParent;

	setParent -m $parent;

	menuItem -divider true;
	menuItem -divider true;

	$mirrorWeightsParent = `menuItem -subMenu false -c "MirrorSkinWeights" -label (uiRes("m_dagMenuProc.kDagMenuMirrorSkinWeights"))`;
	$mirroWeightsOB = `menuItem -subMenu false -ob true -c "MirrorSkinWeightsOptions" $mirrorWeightsParent`;

	$copyWeightsParent = `menuItem -subMenu false -c "CopySkinWeights" -label (uiRes("m_dagMenuProc.kDagMenuCopySkinWeights"))`;
	$copyWeightsOB = `menuItem -subMenu false -ob true -c "CopySkinWeightsOptions" $copyWeightsParent`;

	$pruneWeightsParent = `menuItem -subMenu false -c "PruneSmallWeights" -label (uiRes("m_dagMenuProc.kDagMenuPruneSmallWeights"))`;
	$pruneWeightsOB = `menuItem -subMenu false -ob true -c "PruneSmallWeightsOptions" $pruneWeightsParent`;

	menuItem -subMenu false -c "removeUnusedInfluences" -label (uiRes("m_dagMenuProc.kDagMenuRemoveUnusedInfluences"));

	menuItem -divider true;
	menuItem -divider true;

	string $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kDagMenuInputs")) `;
	menu -e
		-pmc ( "createHistoryMenuItems \""+$menu+"\" "+$object ) $menu;
	setParent -m $parent;

	$menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kDagMenuOutputs")) `;
	menu -e -pmc ( "createFutureMenuItems \""+$menu+"\" "+$object ) $menu;
	setParent -m $parent;

	menuItem -divider true;
	menuItem -divider true;
}


// This has been called because a menu press happened on a DAG object
// So find the Object submenu and add the DAG specific items to it.
//
global proc dagMenuProc(string $parent, string $object)
{
	int $defaultObject = ($object == "");
	if ($defaultObject) {
		// MAYA-67156: If object under the the cursor is not selected or highlighted
		// then use the existing selection/hilite list. (see buildObjectMenuItemsNow.mel)
		string $leadObject[] = `ls -sl -tail 1 -typ transform -typ shape`;
		if (size($leadObject) == 0) {
			$leadObject = `ls -hl -tail 1 -typ transform -typ shape`;
		}
		if (size($leadObject) > 0) {
			$object = $leadObject[0];
		}
	}

	if( hasTraversalMM() ){
		global int $gTraversal;
		if( $gTraversal ){
			if (`popupMenu -e -exists $parent`) {
				setParent -m $parent;
				buildTraversalMM( $object );
			}
			return;
		}
	}
	if (`exists modelingTookitActive` && `modelingTookitActive` && (`nexCtx -q -rmbComplete`) ) {
		ctxCompletion;
		return;
	}
	global string $gArtSelectObject ;
	string $mode = "";

	if (`optionVar -exists currentMenuBarTab`) {
		$mode = `optionVar -q currentMenuBarTab`;
	} else {
		optionVar -sv currentMenuBarTab $mode;
	}

	if (($object == "CubeCompass"))
	{
		createViewCubeMenuItems($parent);
		return;
	}

	if (`popupMenu -e -exists $parent`) {
		setParent -m $parent;

		string  $currContext = `currentCtx`;
		if ( $currContext == "artAttrSkinContext" )
		{
			setUpArtisanSkinContext($parent, $object);
		}
		else
		{
		    // label the object
		    string $shortName = `substitute ".*|" $object ""`;
		    menuItem -label ($shortName + "...") -c ("showEditor "+$object);
		    menuItem -divider true;
		    menuItem -divider true;

		    // Create the list of selection masks
		    createSelectMenuItems($parent, $object, $defaultObject);

		    menuItem -d true;

		    menuItem -label (uiRes("m_dagMenuProc.kSelect"))  -c ("select -r " + $object);
			menuItem -version "2014" -label (uiRes("m_dagMenuProc.kSelectAll"))  -c ("SelectAll");
			menuItem -version "2014" -label (uiRes("m_dagMenuProc.kDeselect"))  -c ("SelectNone;");
		    menuItem -label (uiRes("m_dagMenuProc.kSelectHierarchy"))  -c ("select -hierarchy " + $object);
			menuItem -version "2014" -label (uiRes("m_dagMenuProc.kInverseSelection"))  -c ("InvertSelection");
		    string $container = `container -q -fc $object`;
		    if( $container != "" ){
				string $containerLabel = "";
		        if(`assembly -query -isa $container`){
					$containerLabel = (uiRes("m_dagMenuProc.kSelectAssembly"));
				}
				else
				{
					$containerLabel = (uiRes("m_dagMenuProc.kSelectContainer"));
				}
			    menuItem -label $containerLabel -c ("select -r " + $container);
		    }

    	    menuItem -d true;

			if(`pluginInfo -q -loaded "modelingToolkit"`) {
				menuItem -version "2014" -label (uiRes("m_dagMenuProc.kSelectSimilar"))  -c ("SelectSimilar");
				menuItem -optionBox true  -c ("SelectSimilarOptions");

				menuItem -d true;
			}

			menuItem -d true;
			menuItem -version "2014" -c ("makeLive " + $object) -en (`canMakeLive $object`) -label (uiRes("m_dagMenuProc.kMakeLive"));
			menuItem -d true;

		    optionalDagMenuProc( $parent, $object );

		    // Create the dg traversal menu
		    //
		    string $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kDGTraversal")) `;
		    menu -e
			    -pmc ( "createTraversalMenuItems \""+$menu+"\" "+$object ) $menu;
		    setParent -m $parent;

		    // create the history menu
		    //
		    $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kInputs")) `;
		    menu -e
			    -pmc ( "createHistoryMenuItems \""+$menu+"\" "+$object ) $menu;
		    setParent -m $parent;

		    $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kOutputs")) `;
		    menu -e -pmc ( "createFutureMenuItems \""+$menu+"\" "+$object ) $menu;
		    setParent -m $parent;

	 	    // Look at the shape child of this object
	 	    //
 		    string $shapes[] = `listRelatives -path -s $object`;
		    // get current selection of shapes
		    string $currentSel[] = `ls -sl -dagObjects -shapes` ;

		    string $paintParent = "" ;
		    int $selIndex  ;

 		    int $i;
 		    for ($i = 0; $i < size($shapes); ++$i)
		    {
			    string $nodeType = `nodeType $shapes[$i]` ;

			    if ( ( $nodeType == "nurbsSurface") ||
				     ( $nodeType == "mesh") ||
				     ( $nodeType == "subdiv"))
			    {
				    // save the object name if it is not already selected by the user
				    // We use this info to select the object if user chooses a paint option
				    //
				    // If user has selected multiple objects and is using context menu on one of them
				    // we do not change the selection list as user may want to paint some attribute
				    // on all of them. (It is the way it has been working all along...we don't want to
				    // break it )

				    int $found = 0 ;
				    for( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )
				    {
					    if( $shapes[$i] == $currentSel[ $selIndex  ] )
					    {
						    $found = 1 ;
						    break ;
					    }
				    }

				    if( $found )
				    {
					    $gArtSelectObject = "" ;
				    }
				    else
				    {
					    // check if the object is in component selection mode
					    // and if it is, do not do any further selection.
					    // We are assuming that if the object is in hilite mode
					    // then the user is in component selection mode.

					    $currentSel = `ls -hilite` ;
					    for( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )
					    {
						    if( $object == $currentSel[ $selIndex  ] )
						    {
							    $found = 1 ;
							    break ;
						    }
					    }

					    if( !$found )
						    $gArtSelectObject = $object ;
					    else
						    $gArtSelectObject = "" ;
				    }

				    $paintParent = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kPaintSubmenu")) `;
				    menu -e	-pmc ( "createArtAttrMenuItems \""+ $paintParent +"\" "+$object ) $paintParent ;
				    setParent -m $parent;
				    break ;
			    }
		    }

		    // menuitem for metadata in right click menu list
		    $menu = `menuItem -version 2016 -label (uiRes("m_dagMenuProc.kMetadataMenu")) -subMenu true`;
		    menu -e -pmc ( "createMetadataMenuItems \""+$menu+"\" "+$object ) $menu;
		    setParent -m $parent;

	            $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kActions")) `;
		    menu -e -pmc ( "createActionsMenuItems \""+$menu+"\" "+$object ) $menu;

		    setParent -m $parent;

		    // If the object can handle uv sets then add the uvset menu
		    //
		    string $shape = objectHandlesUvSets( $object );
		    if ($shape != "")
		    {
			    $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kUVSets")) `;
			    menu -e
				    -pmc ( "createUVsetMenuItems \""+$menu+"\" " +$object + " "+ $shape )
				    $menu;
			    setParent -m $parent;
		    }

		    $shape = objectHandlesColorSets( $object );
		    if ($shape != "")
		    {
			    $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kColorSets")) `;
			    menu -e
				    -pmc ( "createColorSetMenuItems \""+$menu+"\" " +$object + " "+ $shape )
				    $menu;
			    setParent -m $parent;
		    }
			$menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kCTEMenu")) -version 2017`;
			menu -e
				-pmc ( "createTimeEditorMenuItems \""+$menu+"\" ")
				$menu;
			setParent -m $parent;

			if(size(`assembly -q -listTypes`) > 0){
			    menuItem -d true;
                $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kSceneAssemblyMenuProc")) `;
                menu -e -pmc ( "createSceneAssemblyMenuItems \""+$menu+"\"" ) $menu;
			    setParent -m $parent;
			}
		    // Shader menu to be able to quickly assign existing shaders
		    // to the object under the pointer.
		    //
    	    menuItem -d true;

 		    menuItem -label (uiRes("m_dagMenuProc.kMaterialAttributes")) -c ("showSG "+$object);

    	    menuItem -d true;

            buildShaderMenus($object);
            // The "Remove Material Override" option is not supported by Render Setup, only by Legacy Render Layers.
            if(!mayaHasRenderSetup())
            {
                menuItem -d true;

                menuItem -divider true;

                string $removeOverrideMenuItem = `menuItem
                    -label (uiRes("m_dagMenuProc.kRemoveMaterialOverride"))
                    -subMenu true`;
                menuItem -edit -postMenuCommand
                    ("buildMaterialRemoveOverrideMenu -surface "+$object+" "+$removeOverrideMenuItem)
                    $removeOverrideMenuItem;
            }
            setParent -m ..;

			// Giving the chance to third parties to add their baking menu items
			//
			callbacks -executeCallbacks -hook "addRMBBakingMenuItems" $object;
			setParent -m $parent;

		    if ($mode == "dynamicsMenuSet") {
			    menuItem -d true;
			    menuItem -label (uiRes("m_dagMenuProc.kConnectField"))  -c ("connectDynamic -f " + $object);
			    menuItem -label (uiRes("m_dagMenuProc.kConnectEmitter"))  -c ("connectDynamic -em " + $object);
			    menuItem -label (uiRes("m_dagMenuProc.kConnectCollision"))  -c ("connectDynamic -c " + $object);
		    }

		    // is there a reference associated with the object ?
		    // and if so, is it in a loaded or unloaded state?
		    string $refNode = `getRelatedReference $object`;

			if( size($refNode) > 0)
			{
				// Check if this reference node is associated with multiple representation.
				string $refObjects[] = `listConnections -s 0 -d 1 -type representation ($refNode+".message")`;
				if (size($refObjects) == 0) // The referende node is not associated with multiple representation, can show reference related menuItems.
				{
					menuItem -d true;
					if( `file -rfn $refNode -q -dr` ) {
						menuItem -label (uiRes("m_dagMenuProc.kLoadRelatedReference"))  -c ("loadRelatedReference " + $object);
					} else {
						menuItem -label (uiRes("m_dagMenuProc.kReloadRelatedReference"))  -c ("loadRelatedReference " + $object);
						menuItem -label (uiRes("m_dagMenuProc.kUnloadRelatedReference"))  -c ("unloadRelatedReference " + $object);
					}
					// Is this reference a proxy? If so, add proxy switch submenu
					//
					string $proxyNodes[] = `getRelatedProxies $refNode`;
					if(size($proxyNodes) > 0) {
						$menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kReloadProxy")) `;
							menu -e
							-pmc ( "createSwitchProxyMenuItems \""+$menu+"\" "+$object + " " + $refNode )
							$menu;
						setParent -m $parent;
					}
				}
			}

		    $container = `container -q -findContainer { $object }`;

		    if (size($container) > 0)
		    {
			    string $menuProc = `getAttr ($container+".rmbCommand")`;
			    if (size($menuProc) > 0)
			    {
				    if (`exists $menuProc`)
				    {
					    string $menuItems[] = `eval $menuProc`;
					    int $mm;
					    int $menuCount = size($menuItems);
					    if ($menuCount % 2 != 0)
					    {
						    // the user provided an invalid # of items, skip
						    // the last
						    //
						    $menuCount--;
					    }
					    if ($menuCount > 0) {
						    string $containerType = `getAttr ($container + ".containerType")`;
						    if ($containerType == "")
						    {
							    menuItem -d true;
							    menuItem - subMenu true -label (uiRes("m_dagMenuProc.kCustom"));
						    }
						    else
						    {
							    menuItem -d true;
							    menuItem -subMenu true -label ($containerType);
						    }
						    for ($mm = 0; $mm < $menuCount; $mm+=2)
						    {
							    menuItem -label $menuItems[$mm] -c ($menuItems[$mm+1]+" "+$object);
						    }
					    }
				    }
				    else {
					    string $warnStr = (uiRes("m_dagMenuProc.kSkippedRmb"));
					    warning(`format -s $menuProc $warnStr`);
				    }
			    }
		    }

		    setParent -m $parent;

        }
	} else {
		string $warn = (uiRes("m_dagMenuProc.kMenuWarn"));
		warning(`format -s $parent $warn`);
	}
}


// Custom menu related procedures
global proc int isComponentSelected() {
	string $sels[] = `ls -sl`;
	string $filteredCpnts[] = `filterExpand -sm 31 -sm 32 -sm 34`;
	if (size($filteredCpnts) > 0) {
		return 1;
	}
	return 0;
}

global proc setSkinWeightSelect(string $joint, float $weight) {
	string $mesh[] = `ls -sl -objectsOnly`;
	string $skinClst = `findRelatedSkinCluster($mesh[0])`;

	string $vertices[] = `ls -sl -fl`;
	skinPercent -transformValue $joint $weight $skinClst $vertices;
}