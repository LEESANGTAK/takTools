// Title:	AxCrack
// 		
// Author:     	Axel Gaertner
// Date:       	January 2010
// Version:    	1.1
// 
// Description:	Splits selected polygon surface into pieces
//  
// AxCrack is undoable, not queryable.
// 
// INSTRCUTIONS	
//	
// It is easy to use: 
// 1. Select one polygon surface
// 2. Run script in command line with "AxCrack"
// 3. A window GUI opens up. Adjust parameters and hit "C R A C K" 
//
// IMPORTANT
//
// This scripts destroys objects, therefore make a copy of your selected object.
// Use this script with care!
//			
// All ideas, comments, improvements welcome!
// copyright (C) 2010 by contact@axelgaertner.de
// http://www.axelgaertner.de
//
// !!!CHANGE ON YOUR OWN RISK!!!
//
// The script is based on the script
// CrackMe v1.0.0 created by Chase Cooper
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to A. Gaertner which is protected by German
// copyright law and by international treaties.
//
// The Data is provided for use exclusively by you. You have the right
// to use and modify the code. 
// However, you are NOT ALLOWED to incorporate this data into other products 
// without authorization by A. Gaertner.
//
// The copyright notices in the software and this entire statement,
// including the above license grant, this restriction and the
// following disclaimer, must be included in all copies of the
// software, in whole or in part, and all derivative works of
// the software, unless such copies or derivative works are solely
// in the form of machine-executable object code generated by a
// source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
// A. GAERTNER DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED
// WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF
// NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
// PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR
// TRADE PRACTICE. IN NO EVENT WILL A. GAERTNER AND/OR ITS LICENSORS
// BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF A. GAERTNER
// AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY
// OR PROBABILITY OF SUCH DAMAGES.
//
// COPY ONLY WITH PERMISSION BY AUTHOUR!!!
// Kopieren nur mit Erlaubnis des Autors!!!
//
//

// AxCrack ---------------------------------------------------------------------------------------------------------------------------------------
// Main Procedure creating the UI

global proc AxCrack()
{

	global int $ScriptJobClean;
	global string $window="AxCrack";
	global int $width=200;

	
	

	print("\nWelcome to AxCrack (Version 1.1)"+
	"\nCopyright by A. Gaertner"+
	"\nwritten for Maya"+
	"\nThank you for using my script!");
	print("\n\n");



	windowClean ($window);
   


	window -tlc 210 390 -wh $width 300 -title ($window+" - Splitting Polygons into Polygon Pieces") -iconName "AxCrack" $window;


	string $menuBarLayout = `menuBarLayout`;
	menu -label "File";
		menuItem -label "Close / Quit" -command ("windowClean "+$window);
	menu -label "Help";
		menuItem -label "About" -command aboutScript;
	string $root = `formLayout`;
	string $parent = `tabLayout -scr true -cr true -imh 10 -imw 10 -parent $root`;
	formLayout -edit
   		-attachForm $parent "top"    0
  		-attachForm $parent "left"   0
   		-attachForm $parent "bottom" 0
 		-attachForm $parent "right"  0
     	$root;	

	// Create Tab01
	tabParameter($parent);
	// Create Tab02
	tabHelp($parent);


	showWindow $window;





}


global proc tabParameter(string $parent) {
	

	//  Create the UI fuer den Tab Import
	// 
	//setUITemplate -pushTemplate NONE;
	
	$width=`tabLayout -q -w $parent`;

	string $MaxMasterFrame=`frameLayout -lv false -mw 20 -mh 10 -w $width -bv false -parent $parent "Parameters for Cracking"`;
	string $MasterFrame=`columnLayout -adj true -rs 10 -parent $MaxMasterFrame`;
	string $Frame01=`frameLayout -l "Options" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame01Col=`columnLayout -adj true -parent $Frame01`;
	string $Frame02=`frameLayout -l "Preparation" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame02Col=`columnLayout -adj true -parent $Frame02`;
	string $Frame03=`frameLayout -l "Expanded Viewing" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame03Col=`columnLayout -adj true -parent $Frame03`;
	string $Frame04=`frameLayout -l "Selection for upcoming Crack" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame04Col=`columnLayout -adj true -parent $Frame04`;
					       

			
		
	optionMenuGrp 
		-label "Knife Shape"
		-parent $Frame01Col
		-cal 1 "right" 
		-cw2 140 170 
		-cc  ("updateTabParameter\""+ $parent+"\"")  knifeShape;
		menuItem -label "Plane";
		menuItem -label "Sphere";
		menuItem -label "Box";
		
	intSliderGrp 
		-cal 1 "right" 
		-cw3 140 70 100   
		-l "Width Division" 
		-minValue 1  
		-maxValue 10 
		-value 5 
		-fieldMinValue 1 
		-fieldMaxValue 20
		-field true  
		-parent $Frame01Col
		 widthDivision;
	intSliderGrp 
		-cal 1 "right" 
		-cw3 140 70 100 
		-l "Height Division" 
		-minValue 1  
		-maxValue 10 
		-value 5 
		-fieldMinValue 1 
		-fieldMaxValue 20
		-field true  
		-parent $Frame01Col
		 heightDivision;
	floatSliderGrp 
		-cal 1 "right" 
		-cw3 140 70 100
		-l "Knife Distortion" 
		-minValue 0  
		-maxValue 1
		-value .3 
		-fieldMinValue 0 
		-fieldMaxValue 5
		-field true  
		-parent $Frame01Col
		 randomizeSurface;
	checkBoxGrp
		-cal 1 "right" 
		-cw4 140 50 50 50
       	 	-numberOfCheckBoxes 3
       		-label "Rotation of Knife"
        	-labelArray3 "x" "y" "z"
		-en1 1 -en2 1 -en3 1
		-v1 1 -v2 1 -v3 1 
		-parent $Frame01Col
		cutPlane;
	optionMenuGrp 
		-label "Crack Order"
		-parent $Frame01Col
		-cal 1 "right" 
		-cw2 140 170 
		-cc  ("updateTabParameter\""+ $parent+"\"")  CrackOrder;
		menuItem -label "Evenly distributed";
		menuItem -label "Biggest next";
		menuItem -label "Smallest next";
		menuItem -label "Random next";
	intSliderGrp 
		-cal 1 "right" 
		-cw3 140 70 100
		-l "Iterations" 
		-minValue 1  
		-maxValue 7
		-value 3
		-fieldMinValue 1 
		-fieldMaxValue 10
		-field true  
		-parent $Frame01Col
		iterations;
	checkBoxGrp
		-cal 1 "right" 
		-cw4 140 70 70 70
       	 	-numberOfCheckBoxes 1
       		-label "Force Verticsmerge"
      		-en1 1
		-v1 0 
		-parent $Frame01Col
		forceMerge;
	textFieldGrp
		-cal 1 "right" 
		-cw2 140 170 
       		-label "Crack Shader"
        		-text  "ShaderForCrack"
		-parent $Frame01Col 
		CrackShader;

	separator -style "none" -height 10 -parent $Frame01Col;
	button 
		-label "C R A C K" 
		-h 50 
		-c crackSurface 
		-parent $Frame01Col 
		ButtonCrack;
	separator -style "none" -height 10 -parent $Frame01Col;
	button 
		-label "Undo last cracking (Undo command)" 
		-c undo 
		-parent $Frame01Col 
		ButtonUndoCrack;
	button 
		-label "MERGE VERTICS to prevent Objects to disappear" 
		-c mergeVertics 
		-h 30
		-parent $Frame02Col 
		ButtonMergeVertics;
	

	floatSliderGrp 
		-cal 1 "right" 
		-cw3 140 70 100 
		-l "Expand Distance" 
		-minValue 0  
		-maxValue 3 
		-value 2
		-fieldMinValue 1 
		-fieldMaxValue 100 
		-field true  
		-parent $Frame03Col
		distance;
	button 
		-label "Expand Pieces" 
		-h 30 
		-c ExecuteExpandPieces 
		-parent $Frame03Col;

	separator -style "none" -height 10 -parent $Frame03Col;
	button 
		-label "Undo Expand Pieces (Needs to be done)" 
		-c UndoExpandPieces 
		-parent $Frame03Col;	
	
	button 
		-label "SELECT RANDOM piece from current selection" 
		-c selectRandomObj 
		-h 30
		-parent $Frame04Col 
		ButtonSelectRandomObj;

	separator -style "none" -height 10 -parent $Frame04Col;

	button 
		-label "SELECT BIGGEST piece from current selection" 
		-c selectBiggestObj 
		-h 30
		-parent $Frame04Col 
		ButtonSelectBiggestObj;	
	separator -style "none" -height 10 -parent $Frame04Col;

	button 
		-label "SELECT SMALLEST piece from current selection" 
		-c selectSmallestObj 
		-h 30
		-parent $Frame04Col 
		ButtonSelectSmallesttObj;	

	}
global proc updateTabParameter(string $parent) {

	string $optionKnifeShape=`optionMenuGrp -q -v knifeShape`;
	switch ($optionKnifeShape) {
	case "Plane":
	intSliderGrp -e
		-l "Width Division" 
		-minValue 1  
		-maxValue 10 
		-value 5 
		-fieldMinValue 1 
		-fieldMaxValue 20
		-field true  
		 widthDivision;
	intSliderGrp -e
		-l "Height Division" 
		-minValue 1  
		-maxValue 10 
		-value 5 
		-fieldMinValue 1 
		-fieldMaxValue 20
		-field true 
		-vis 1 
		 heightDivision;
	checkBoxGrp -e
		-vis 1
		cutPlane;
	break;

	case "Sphere":
	intSliderGrp -e 
		-l "X Division" 
		-minValue 1  
		-maxValue 30 
		-value 12 
		-fieldMinValue 1 
		-fieldMaxValue 50
		-field true  
		 widthDivision;
	intSliderGrp -e 
		-l "Y Division" 
		-minValue 1  
		-maxValue 30 
		-value 12 
		-fieldMinValue 1 
		-fieldMaxValue 50
		-field true 
		-vis 1 
		 heightDivision;
	checkBoxGrp
		-e
		-vis 0
		cutPlane;
	break;

	case "Box":
	intSliderGrp -e 
		-l "Division for all sides" 
		-minValue 1  
		-maxValue 30 
		-value 6 
		-fieldMinValue 1 
		-fieldMaxValue 50
		-field true  
		 widthDivision;
	
	intSliderGrp -e 
		-vis 0
		 heightDivision;
	checkBoxGrp
		-e
		-vis 1
		cutPlane;
	break;
	}
}

global proc tabHelp(string $parent) {

	setUITemplate -pushTemplate NONE;
	$width=`tabLayout -q -w $parent`;	
	string $MaxMasterFrame=`frameLayout -lv false -mw 20 -mh 10 -w $width -bv false -parent $parent "Help and Instructions"`;
	string $MasterFrame=`columnLayout -adj true -rs 10 -parent $MaxMasterFrame`;
	string $Frame00=`frameLayout -l "Welcome to the AxCrack MEL Script Tool!" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame00Col=`columnLayout -adj true -parent $Frame00`;
	string $Frame01=`frameLayout -l "Options" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame01Col=`columnLayout -adj true -parent $Frame01`;
	string $Frame02=`frameLayout -l "Preparation" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame02Col=`columnLayout -adj true -parent $Frame02`;
	string $Frame03=`frameLayout -l "Expanded Viewing" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame03Col=`columnLayout -adj true -parent $Frame03`;
	string $Frame04=`frameLayout -l "Selection for upcoming Crack" -bv true -la "center" -li 10 -lv true -mw 10 -mh 10 -w $width -bs "etchedIn" -parent $MasterFrame `;
	string $Frame04Col=`columnLayout -adj true -parent $Frame04`;
			text -l "One polygon surface can be splitted or rather cracked into smaller parts. Always crack a copy of your object to prevent chaos. Select one polygon surface and adjust the knife parameters. Hit C R A C K. Done."  -parent $Frame00Col;
			text -l "Download the full version on"-parent $Frame00Col;
			text -l "www.axelgaertner.de/axcrack"-parent $Frame00Col;
			text -l "if you have the light version. Also visit my website for more informations:"-parent $Frame00Col;
			text -l "www.axelgaertner.de"-parent $Frame00Col;

			separator -style "none" -height 10 -parent $Frame00Col;
			text -l "Have fun destroying your virtual object."-parent $Frame00Col;	
			text -l "Respect your environment. Respect human rights. Respect culture. Peace and Love!"-parent $Frame00Col;
			
			text -l "Knife Shape:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "A plane, sphere or box will slice the object apart called the knife shape. According to the selection of the knife shape the parameters will be adjusted."-parent $Frame01Col;
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "Division Height and Width:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "To get more details in the resulting crack increase the width and height division which simply increases the division of the defined knife shape."-parent $Frame01Col;
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "Knife Distortion:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "Those knife shapes can be distorted with knife distortion. Too high value will let the boolean operation to fail. It is a relative value."-parent $Frame01Col;
			
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "Knife Rotation:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "The knife shapes are being rotated randomly. You can decided in which axis this should occur with adjusting the rotation of the knife."-parent $Frame01Col;
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "Crack Order:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "Here you can decide which philosophy to crack the object apart. Each option is a little different and gives a different result. \n\n Evenly distributed:\n Every piece created will be sliced again depending on how many iterations are set.\n\n Biggest, smallest and random next are easy: \n Usually more pieces are created then one. \nYou can decide which piece will be consider next. \nEither random, the smallest or the biggest." -parent $Frame01Col;
			separator -style "none" -height 10 -parent $Frame01Col;			
			text -l "Iteration:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l " The iteration is an indicator how often your object will be cracked. High values will increase processing time. However, it is not the number of slices due to the used technique.\n I recommend to use lower iterations values and use the tool more times on the same object."-parent $Frame01Col;
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "Force Verticsmerge:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "The cracking is based on the boolean function. Therefore not all object can easily be sliced.\nAlways test different parameter values to get a crack result.\nThe force vertices parameter sometimes helps to get less mistakes in the resulting cracked objects."-parent $Frame01Col;
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "Crack Shader:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "With each crack the surfaces inside are being assigned a shader. \nYou can change the name or the default shader is being used which you can adjust after finishing the cracking."-parent $Frame01Col;
			
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "C R A C K:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "Execute the script by hitting this big button."-parent $Frame01Col;
			separator -style "none" -height 10 -parent $Frame01Col;
			text -l "Undo last cracking:"-parent $Frame01Col -fn "smallBoldLabelFont";
			text -l "If the cracking failed somehow, you can undo it. It is just the undo command"-parent $Frame01Col;
			
			text -l "MERGE Vertics:"-parent $Frame02Col -fn "smallBoldLabelFont";
			text -l "You can use this before and after cracking the object. By using this, you can sometimes prevent that object disappear after hitting the C R A C K button."-parent $Frame02Col;
			
			text -l "Expand Distance:"-parent $Frame03Col -fn "smallBoldLabelFont";
			text -l "The pieces are being moved apart with the following button. This is the value for the distance."-parent $Frame03Col;
			separator -style "none" -height 10 -parent $Frame03Col;

			text -l "Expand Pieces:"-parent $Frame03Col -fn "smallBoldLabelFont";
			text -l "Press this button to move the pieces apart."-parent $Frame03Col;
			separator -style "none" -height 10 -parent $Frame03Col;
			text -l "Undo Expand Pieces:"-parent $Frame03Col -fn "smallBoldLabelFont";
			text -l "Press this button to undo the expansion. It is a simple undo comment. But the Crack Button is disabled as long as you do not undo the expansion."-parent $Frame03Col;
			
			text -l "SELECT RANDOM:" -parent $Frame04Col -fn "smallBoldLabelFont";
			text -l "Press this button to select a random piece from the current selection. \nAfter finishing all crack pieces are being selected, but since you can only crack one polygon object with this tool, the following tools help to select the next piece."-parent $Frame04Col;
			separator -style "none" -height 10 -parent $Frame04Col;

			text -l "SELECT BIGGEST:"-parent $Frame04Col -fn "smallBoldLabelFont";
			text -l "Press this button to select the biggest piece in the current selection based on the bounding box."-parent $Frame04Col;
			separator -style "none" -height 10 -parent $Frame04Col;

			text -l "SELECT SMALLEST:"-parent $Frame04Col -fn "smallBoldLabelFont";
			text -l "Press this button to select the smallest piece in the current selection based on the bounding box."-parent $Frame04Col;
			separator -style "none" -height 10 -parent $Frame04Col;
				
		

}

global proc aboutScript()
{

        string $window = "aboutWindow";
	windowClean($window);
	window -w 450 -h 200 -title "About AxCrack" $window;
	string $tabParent=`frameLayout -lv false -bv true -bs "etchedIn" -mw 10 -mh 10`;
        columnLayout  -adjustableColumn true  -parent $tabParent;
        text "Created by: Axel Gaertner";
        text "http://www.axelgaertner.de";
        text "email: axelgaertner@web.de";
	text "Version 1.1 - FULL VERSION";
	setParent..;
	showWindow $window;
}
global proc string createTexture (string $ShaderTyp, string $ShaderName)
{
	string $node = `shadingNode -asShader $ShaderTyp`;
	string $Texture=`rename $node ($ShaderName)`;
	string $shadingGroup = `sets -renderable true -noSurfaceShader true -empty -name ($Texture+"SG")`;
	connectAttr -f ($Texture+".outColor ")  ($shadingGroup+".surfaceShader");
	return $Texture;
}
global proc assignTexture (string $TextureName, string $objectName) 
{
	sets -e -forceElement ($TextureName+"SG") $objectName;	
}
global proc ExecuteExpandPieces () 
{
	float $distance=`floatSliderGrp -q -v distance`;
	ExpandPieces ($distance);
	separator -style "none" -height 10;
	button -e -vis 0 ButtonCrack;
	button -e -vis 0 ButtonUndoCrack;		
}

global proc UndoExpandPieces () 
{
	undo;
	button -e -vis 1 ButtonCrack;
	button -e -vis 1 ButtonUndoCrack;	
}
global proc ExpandPieces (float $distance) 
{
	
	string $object[]=`ls -sl`;
	$distance=$distance+1;
	AxPivotCenteringIntern;	
	string $GroupName="TempGroup";
	group -n $GroupName;
	AxPivotCenteringIntern;	
	float $xOrigin=`getAttr($GroupName+".translateX")`;
	float $yOrigin=`getAttr($GroupName+".translateY")`;
	float $zOrigin=`getAttr($GroupName+".translateZ")`;
	ungroup $GroupName;
	AxPivotCenteringIntern;		
	for ($objNr = 0; $objNr < size($object); $objNr++)
	{
		//Move them apart	
		float $xObjectPos=`getAttr($object[$objNr]+".translateX")`;
		float $yObjectPos=`getAttr($object[$objNr]+".translateY")`;
		float $zObjectPos=`getAttr($object[$objNr]+".translateZ")`;
		float $xMove= $xOrigin+$distance*($xObjectPos-$xOrigin);
		float $yMove= $yOrigin+$distance*($yObjectPos-$yOrigin);
		float $zMove= $zOrigin+$distance*($zObjectPos-$zOrigin);
		setAttr ($object[$objNr]+".translateX") $xMove;
		setAttr ($object[$objNr]+".translateY") $yMove;
		setAttr ($object[$objNr]+".translateZ") $zMove;
	}
}
global proc selectRandomObj () 
{
	string $obj[] = `ls -sl`;
	if (size($obj)>0)
	{
		int $random=`rand(size($obj))`;
		select -cl;
		select -add $obj[$random];
	}
}
global proc selectBiggestObj () 
{
	string $obj[] = `ls -sl`;
	float $volumemax=0;
	int $BiggestObject=0;
	if (size($obj)>0)
	{
		for ($objNr = 0; $objNr < size($obj); $objNr++)
		{
			float $BBinfo[]=`xform -q -bb $obj[$objNr]`;
			float $X =(($BBinfo[3] - $BBinfo[0])); 
			float $Y =(($BBinfo[4] - $BBinfo[1]));
			float $Z =(($BBinfo[5] - $BBinfo[2]));
			float $volume=$X*$Y*$Z;
			if ($volumemax<$volume)
			{
				$volumemax=$volume;
				$BiggestObject=$objNr;				
			}
		}
		select -cl;
		select -add $obj[$BiggestObject];
	}
}
global proc selectSmallestObj () 
{
	string $obj[] = `ls -sl`;
	float $volumemin;
	int $SmallestObject=0;
	if (size($obj)>0)
	{		
		for ($objNr = 0; $objNr < size($obj); $objNr++)
		{
			float $BBinfo[]=`xform -q -bb $obj[$objNr]`;
			float $X =(($BBinfo[3] - $BBinfo[0])); 
			float $Y =(($BBinfo[4] - $BBinfo[1]));
			float $Z =(($BBinfo[5] - $BBinfo[2]));
			float $volume=$X*$Y*$Z;
			if ($objNr==0)
			{
				$volumemin=$volume;
				$SmallestObject=$objNr;	
			}
			if ($volumemin>$volume)
			{
				$volumemin=$volume;
				$SmallestObject=$objNr;
				
			}
		}
		select -cl;
		select -add $obj[$SmallestObject];
	}
}
global proc mergeVertics () 
{
	string $obj[] = `ls -sl`;
	if (size($obj)>0)
	{
		for ($objNr = 0; $objNr < size($obj); $objNr++)
		{
			select -r $obj[$objNr];
			ConvertSelectionToVertices;
			polyMergeVertex  -d 0.01 -ch 1;			
		}
		select -cl;
		for ($objNr = 0; $objNr < size($obj); $objNr++)
		{
			select -add $obj[$objNr];
		}
	}
}
global proc string createPlaneKnife(float $surfaceSize)
{
	int $widthDiv=`intSliderGrp -q -v  widthDivision`; 
	int $heightDiv=`intSliderGrp -q -v  heightDivision`; 
	float $randomizeSurface=`floatSliderGrp -q -v  randomizeSurface`;
	string $objToCrack[]=`ls -sl`;	
	string $obj[] = `ls -sl`;
  	string $knifeSurface[]=`polyPlane -ch on -o on -w $surfaceSize -h $surfaceSize -sw $widthDiv -sh $heightDiv -cuv 2`;
	select -r $knifeSurface;
	ConvertSelectionToVertices;
	string $vertix[]=`ls -sl -fl`;
	for ($vertNr = 0; $vertNr < size($vertix); $vertNr++)
	{
		float $Pos[]=`xform -q -ws -t $vertix[$vertNr]`;
		float $LengthVector=`mag <<$Pos[0], $Pos[1], $Pos[2]>>`;
		$X=`rand (-$randomizeSurface/2) ($randomizeSurface/2)`;			
		xform -ws -t ($Pos[0]) ( ($surfaceSize/2)*$X) ($Pos[2]) $vertix[$vertNr];		
	}
	select -cl;
	for ($objNr = 0; $objNr < size($objToCrack); $objNr++)
	{
		select -add $objToCrack[$objNr];
	}

	return $knifeSurface[0];
	
}
global proc string createSphereKnife(float $surfaceSize)
{
	int $widthDiv=`intSliderGrp -q -v  widthDivision`; 
	int $heightDiv=`intSliderGrp -q -v  heightDivision`; 
	float $randomizeSurface=`floatSliderGrp -q -v  randomizeSurface`;

	float $radius = ($surfaceSize/2);
	string $knifeSurface[]=`polySphere -ch on -o on -r $radius  -sx $widthDiv -sy $heightDiv`; 
	$objToCrack=`ls -sl`;
	select -r $knifeSurface;
	ConvertSelectionToVertices;
	string $vertix[]=`ls -sl -fl`;
	for ($vertNr = 0; $vertNr < size($vertix); $vertNr++)
	{
		float $Pos[]=`xform -q -ws -t $vertix[$vertNr]`;
		float $LengthVector=`mag <<$Pos[0], $Pos[1], $Pos[2]>>`;
		$X=1+`rand $randomizeSurface`;			
		xform -ws -t ($Pos[0]*$X) ($Pos[1]*$X) ($Pos[2]*$X) $vertix[$vertNr];		
	}
	select -r $objToCrack; 
	return $knifeSurface[0];	
}


//  createBoxKnife---------------------------------------------------------------------------------------------------------------------------------------
// Create Box to cut the plane, returns name of sphere

global proc string createBoxKnife(float $surfaceSize)
{
	int $widthDiv=`intSliderGrp -q -v  widthDivision`; 
	float $randomizeSurface=`floatSliderGrp -q -v  randomizeSurface`;
	float $radius = ($surfaceSize/2);
	string $knifeSurface[]=`polyCube -ch on -o on -w $surfaceSize -h $surfaceSize -d $surfaceSize -sw $widthDiv -sh $widthDiv -sd $widthDiv -cuv 4`; 
	$objToCrack=`ls -sl`;
	select -r $knifeSurface;
	ConvertSelectionToVertices;
	string $vertix[]=`ls -sl -fl`;
	for ($vertNr = 0; $vertNr < size($vertix); $vertNr++)
	{
		float $Pos[]=`xform -q -ws -t $vertix[$vertNr]`;
		float $LengthVector=`mag <<$Pos[0], $Pos[1], $Pos[2]>>`;

		// +1 to make sure sphere does not get to small
		$X=1+`rand $randomizeSurface`;	
		
		xform -ws -t ($Pos[0]*$X) ($Pos[1]*$X) ($Pos[2]*$X) $vertix[$vertNr];
		
	}
	select -r $objToCrack;
	return $knifeSurface[0];	
}
global proc crackSurface()
{
		

	print ("C R A C K ! Peace on Earth!");

	string $object[] = `ls -sl`;

	if (size($object)==0)
	{
			confirmDialog 
				-title "Dear User!" 
				-message "No object selected. Please select a polygon surface. Thanks." 
				-button "OK" 
				-defaultButton "OK" ;
	}

	else 
	{	if (size($object)>1)
		{
			confirmDialog 
				-title "Dear User!" 
				-message "More than one object selected. Please select only one polygon surface. Thanks." 
				-button "OK" 
				-defaultButton "OK" ;
			select -cl;
		}
		else
		{

			string $objectShape[]=`listRelatives $object[0]`;
			string $objectTypeCheck=`objectType $objectShape[0]`;
			if ($objectTypeCheck!="mesh")
			{
				confirmDialog 
					-title "Dear User!" 
					-message "No polygon surface selected. Please select one polygon surface. Thanks." 
					-button "OK" 
					-defaultButton "OK" ;
				select -cl;
			}
		}
	}	
	int $iterations=`intSliderGrp -q -v iterations`;
	string $knifeShape = `optionMenuGrp -q -v knifeShape`;
	AxPivotCenteringIntern;
	string $objectTemp[] = `ls -sl`;
	string $CrackShader=`textFieldGrp -q -text CrackShader`;	
	string $TextureName;	
	if (`objExists $CrackShader`)
	{			
		$TextureName = $CrackShader;
	}
	else
	{			
		$TextureName=`createTexture "lambert" $CrackShader`;
		setAttr -e -l true ($TextureName+".color") -type double3 1 0 0;
	}

	select -cl;
	select -add $objectTemp[0];
	for ($x = 0; $x < $iterations; $x++)
	{
	string $object[] = `ls -sl`;
	string $objectsNew[] = `ls -sl`;


	float $forceMerge=`checkBoxGrp -q -v1 forceMerge`;
	if ($forceMerge==1)
		{
		mergeVertics;
		}
		for ($objNr = 0; $objNr < size($object); $objNr++)
		{

		if (`objExists $object[$objNr]`)
		{

			string $CrackOrder = `optionMenuGrp -q -v CrackOrder`;

			switch ($CrackOrder) {
				case "Biggest next":
						selectBiggestObj;
					break;
				case "Smallest next":
						selectSmallestObj;
					
					break;
				case "Random next":
						selectRandomObj;
					
					break;
				}
			if ($CrackOrder!="Evenly distributed")
			{
				string $objectCrackOrder[] = `ls -sl`;
				$objNr = size($object);
				$object[$objNr]=$objectCrackOrder[0];				
			}

			float $BBinfo[]=`xform -q -bb $object[$objNr]`;
			float $X =(($BBinfo[3] - $BBinfo[0])); 
			float $Y =(($BBinfo[4] - $BBinfo[1]));
			float $Z =(($BBinfo[5] - $BBinfo[2]));
			$temp=`max $X $Y`;
			float $surfaceSize=`max $temp $Z`; 
						switch ($knifeShape) {
			case "Plane":
					string $knifeSurface=`createPlaneKnife ($surfaceSize+2)`;
					float $cutPlaneX=`checkBoxGrp -q -v1 cutPlane`;
					if ($cutPlaneX==1){$X=`rand 360`;}
					else	{$X=0;}
					float $cutPlaneY=`checkBoxGrp -q -v2 cutPlane`;
					if ($cutPlaneY==1){$Y=`rand 360`;}
					else	{$Y=0;}
					float $cutPlaneZ=`checkBoxGrp -q -v3 cutPlane`;
					if ($cutPlaneZ==1){$Z=`rand 360`;}
					else	{$Z=0;}	
					xform -ro $X $Y $Z $knifeSurface;

					float $Data[]=`xform -q -t $object[$objNr]`;
					xform -t $Data[0] $Data[1] $Data[2] $knifeSurface;					
					break;
			case "Sphere":

					// reduce size to avoid weird results like egg shells ;)
					string $knifeSurface=`createSphereKnife ($surfaceSize*1.2)`;
					float $radius=$surfaceSize/2;				
					float $X=`rand (-1*$radius) $radius`;
					float $Y=`rand (-1*$radius) $radius`;
					float $Z=`rand (-1*$radius) $radius`;
					$LengthVector=`mag <<$X, $Y, $Z>>`;

					if ( $LengthVector==0)
					{ $LengthVector=1; $X=1;}
			
					float $Pos[]=`xform -q -t $object[$objNr]`;
					xform -t ($Pos[0]+($X/$LengthVector)*$radius) ($Pos[1]+($Y/$LengthVector)*$radius) ($Pos[2]+($Z/$LengthVector)*$radius) $knifeSurface;
					
					break;
			case "Box":
					 
					string $knifeSurface=`createBoxKnife ($surfaceSize)`;
					float $radius=$surfaceSize/2;
					
					
					float $X=`rand (-1*$radius) $radius`;
					float $Y=`rand (-1*$radius) $radius`;
					float $Z=`rand (-1*$radius) $radius`;
					$LengthVector=`mag <<$X, $Y, $Z>>`;
					
					
					if ( $LengthVector==0)
					{ $LengthVector=1; $X=1;}
			
					float $Pos[]=`xform -q -t $object[$objNr]`;
					xform -t ($Pos[0]+($X/$LengthVector)*$radius) ($Pos[1]+($Y/$LengthVector)*$radius) ($Pos[2]+($Z/$LengthVector)*$radius) $knifeSurface;
					
					float $cutPlaneX=`checkBoxGrp -q -v1 cutPlane`;
					if ($cutPlaneX==1){$X=`rand 180`;}
					else	{$X=0;}
					float $cutPlaneY=`checkBoxGrp -q -v2 cutPlane`;
					if ($cutPlaneY==1){$Y=`rand 180`;}
					else	{$Y=0;}
					float $cutPlaneZ=`checkBoxGrp -q -v3 cutPlane`;
					if ($cutPlaneZ==1){$Z=`rand 180`;}
					else	{$Z=0;}

					xform -ro $X $Y $Z $knifeSurface; 
					
					break;
			}

			assignTexture ($TextureName, $knifeSurface);
			
			string $duplicateObject[] = `duplicate -rr $object[$objNr]`;
  			string $duplicatePlane[] = `duplicate -rr $knifeSurface`;

			polyNormal -normalMode 3 -ch 0 $duplicatePlane[0];			
			string $booleanA[] = `polyBoolOp -op 2 -ch 0 $object[$objNr] $knifeSurface`;
			string $booleanB[] = `polyBoolOp -op 2 -ch 0 $duplicateObject[0] $duplicatePlane[0]`;	
			float $BBinfo[]=`xform -q -bb $booleanA[0]`;
			float $MoreThanNothingA =(($BBinfo[3] - $BBinfo[0]));
			if ($MoreThanNothingA==0)
			{
				delete $booleanA[0];
			} 

			float $BBinfo[]=`xform -q -bb $booleanB[0]`;
			float $MoreThanNothingB =(($BBinfo[3] - $BBinfo[0])); 
			if ($MoreThanNothingB==0)
			{
				delete $booleanB[0];
			} 

			string $unitedBoolean[];
			string $crackedObject[];
			$unitedBoolean[0]="";
			$crackedObject[0]="";
			
		
			if (`objExists $booleanA[0]` && `objExists $booleanB[0]`)
			{
				$unitedBoolean=`polyUnite -ch 0 $booleanA[0] $booleanB[0]`;
				$crackedObject=`polySeparate -ch 0 $unitedBoolean[0]`; 
				ungroup $unitedBoolean[0]; 			
			}

			else 
			{
				if (`objExists $booleanA[0]`)
					{ $crackedObject[0]= $booleanA[0]; }
				if (`objExists $booleanB[0]`)
					{ $crackedObject[0]= $booleanB[0]; }
			}	
			
			if (`objExists $crackedObject[0]`)
			{               
				
				$sizeOfArray=size($objectsNew);
				for ($objNrCr = 0; $objNrCr < size($crackedObject); $objNrCr++)
				{
					$crackedObject[$objNrCr]=`rename $crackedObject[$objNrCr] ($crackedObject[$objNrCr]+"_crack")`;
					$objectsNew[$sizeOfArray+$objNrCr]= $crackedObject[$objNrCr];					
				}
			}
						
		}
		
		print (".");
		}
		
		for ($objN = 0; $objN < size($objectsNew); $objN++)
			{
				if (`objExists $objectsNew[$objN]`)
				{
					select -add $objectsNew[$objN];
				}
			}

		AxPivotCenteringIntern;
		
	}
	
	print ("FINISH! Save the Planet!");

}
global proc AxPivotCenteringIntern ()
{	
	float $shift[];
	string $cmd;	
	string $object[]=`ls -sl`;
	for ($objNr = 0; $objNr < size($object); $objNr++)
	{
		
		xform -cp $object[$objNr];

		
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $object[$objNr];
	
		
	 	$shift=`xform -q -rp $object[$objNr]`;

		
		$shift[0]=$shift[0]*-1;
		$shift[1]=$shift[1]*-1;
		$shift[2]=$shift[2]*-1;
		xform -t $shift[0] $shift[1] $shift[2] $object[$objNr];

		
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $object[$objNr];
		

		$shift[0]=$shift[0]*-1;
		$shift[1]=$shift[1]*-1;
		$shift[2]=$shift[2]*-1;
	 	xform -t $shift[0] $shift[1] $shift[2] $object[$objNr];

		
		xform -ztp $object[$objNr];
		
	}
}
global proc windowClean(string $window){
	
	// delete window
	if (`window -exists $window`) deleteUI -window $window;
	//  clean up the whole scene
	//may be more to come

}




