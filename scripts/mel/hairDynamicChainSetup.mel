
// procedure


global proc matchPosition(string $a , string $b)
{	
	string $ptCsObj[] = `parentConstraint $b $a`;

	string $findPtCns[] = `listRelatives -type parentConstraint $a`;

	select $findPtCns; doDelete;
}


global proc setupDynamicChain( string $name , string $path ) {

string $namespace = "hairTemp";

string $ext = "";
if (`fileExtension($path)` == "ma" )
	$ext = "mayaAscii";
else if (`fileExtension($path)` == "mb" )
	$ext = "mayaBinary";
else
	error "It is not maya file.\n";	

file -import -type $ext -ra true -mergeNamespacesOnClash false -namespace $namespace -options "v=0;"  -pr -loadReferenceDepth "all" $path;


string $list[] = `ls -typ "transform" ($namespace + ":*")`;

string $numName =  ($name + "0");
for ( $i=0 ; `objExists ($numName + "_*")` ; $i++ ) {
    $numName = $name + $i;
}

for ( $curList in $list ) {
    
    if (`gmatch $curList ($namespace + ":*name_*")`) 
    {
        string $newName = `substitute "name_" $curList ($numName + "_")`;
        //print ($curList + " >>> " + $newName + "\n");
        rename $curList $newName;
    }
    else 
        print ( $curList + " is not contian name_ \n");
        
}

namespace -force -mv $namespace ":";
namespace -rm $namespace;

optionVar -sv "IKchainPath" $path;

}

global proc BHCfileDialog(string $UI , string $dir ) {
	string $filename[] = `fileDialog2 -fileMode 1 -ds 1 -dir $dir -caption "Import control"`;
	if (1 == `size($filename)`){
		textFieldButtonGrp -e -text $filename $UI;
	}	
}

global proc skinCopyWithSkin() {
	string $listSel[] = `ls -sl`;
	string $temp[];
	string $sourceShape;
	if ( `objectType $listSel[0]` == "transform" ) {
		$temp = `listRelatives -s $listSel[0]`;
		$sourceShape = $temp[0];	
	}
	else if ( `objectType $listSel[0]` == "mesh" ) {
		$sourceShape = $listSel[0];
	} else
		error "Select a Source mesh with skin cluster";
		
	string $skinCluster = `findRelatedSkinCluster $sourceShape`;
	
	string $jointList[] = `skinCluster -q -inf $sourceShape`;
	
	string $targetShape;
	$temp = `listRelatives -c -s $listSel[1]`;
	if ( `objectType $listSel[1]` == "transform" ) {
		$temp = `listRelatives -s $listSel[1]`;
		$targetShape = $temp[0];	
	}
	else if ( `objectType $listSel[1]` == "mesh" ) {
		$targetShape = $listSel[1];
	} else
		error "Select a Source mesh with skin cluster";
	
	$temp = `skinCluster -mi 1 -dr 4.5 -tsb $jointList $targetShape` ;
	string $DesSkin = $temp[0];	
	
	copySkinWeights -sa "closestPoint" -ia "oneToOne" -ss $skinCluster -ds $DesSkin -nm;
}

global proc setHairBake() {

	string $list[] = `ls -sl`;
	
	for ( $curSel in $list ) {

		string $tokenTemp[];
		tokenize $curSel "_" $tokenTemp;
		string $pre = $tokenTemp[0];
		print ($pre + ":");
		for ($i = 1 ; $i <= 5 ; ++$i ) {	
			float $zeroRot[] = `getAttr ($pre + "_Line" + $i + "_Zero.r" )`;	
			setAttr ($pre + "_Line" + $i + "_Bake_Zero.r" ) $zeroRot[0] $zeroRot[1] $zeroRot[2]; 
			print ($pre + "_Line" + $i + "_Zero.r" );
		}
	}
	print ("\n");
}

global proc b1checkUniqName(){
	string $list[] = `ls `;
	string $uniqSet = `sets -em -n "uniqSet"`;
	for ( $curlist in $list ) {
		string $tem[];
		int $size = `tokenize $curlist "|" $tem`;
		if ($size > 1 ){
			print ($curlist + "\n");
			sets -add $uniqSet $curlist;
		}	
	}
	if (size(`sets -q $uniqSet`) == 0 ){
		delete $uniqSet;
		print "//result : good ! \n";	
	}

}

global proc b1checkTransformFreeze(){
	string $selGeoArray[];
	string $noneFreezeArray[];
	
	string $curSel[0] = `ls -sl -head 1`;
	string $trSet = `sets -em -n "transformSet"`;
	string $selGeoArray[] = `listRelatives -c -ad -type "transform" $curSel[0]`;


	for ($num = 0 ; $num < (size($selGeoArray)) ; $num++ )
	{
		   string $currentGeo = $selGeoArray[$num];
           string $curShape[] = `listRelatives -s $currentGeo`;
           
           if ( size($curShape) > 0 && `objectType $curShape[0]` == "camera" ) 
               continue;
	  //1.object transform 체크.
	  
			float $objectTr[] = `xform -q -t $currentGeo`;
			float $objectRo[] = `xform -q -ro $currentGeo`; 
			float $objectSc[] = `xform -r -q -s $currentGeo`;         
		   
			if (($objectTr[0] != 0) || ($objectTr[1] != 0) || ($objectTr[2] != 0)){
					print ($currentGeo + ": \n" + "Tr : " + $objectTr[0] + " / " + $objectTr[1] + " / " + $objectTr[2] + "\n");
					sets -add $trSet $currentGeo;
			} else if  (($objectRo[0] != 0) || ($objectRo[1] != 0) || ($objectRo[2] != 0)){
					print ($currentGeo + ": \n" + "Ro : " + $objectRo[0] + " / " + $objectRo[1] + " / " + $objectRo[2] + "\n");
					sets -add $trSet $currentGeo;
			} else if  (($objectSc[0] != 1) || ($objectSc[1] != 1) || ($objectSc[2] != 1)){ 
					print ($currentGeo + ": \n" + "Sc : " + $objectSc[0] + " / " + $objectSc[1] + " / " + $objectSc[2] + "\n");
					sets -add $trSet $currentGeo;
			}		
	}
	if (size(`sets -q $trSet`) == 0 ){
		delete $trSet;
		print "//result : good ! \n";	
	}
	

}
//hairChain match
//targetMesh 선택하고 sourceMesh 선택.
global proc b1matchingHairChain( int $mirrorX ) {
    
    string $sel[] = `ls -sl`;
    string $tokenTemp[];
	tokenize $sel[0] "_" $tokenTemp;    
    string $target = $tokenTemp[0]; 
    tokenize $sel[1] "_" $tokenTemp;       
    string $source = $tokenTemp[0];
    
    
	if ( !`objExists ( $target + "_Block" )` )
		error;
	// matchBlockTop
	float $jointTr[] = `getAttr ($target + "_Block.t")`;
    float $jointRt[] = `getAttr ($target + "_Block.r")`;
    float $jointSc[] = `getAttr ($target + "_Block.s")`;
	
    if ( $mirrorX ) {
		setAttr ($source + "_Block.t") (-$jointTr[0]) $jointTr[1] $jointTr[2];
		setAttr ($source + "_Block.r")  $jointRt[0] (-$jointRt[1]) (-$jointRt[2]);
		setAttr ($source + "_Block.s")  $jointSc[0] $jointSc[1] $jointSc[2];
	} else {
		setAttr ($source + "_Block.t")  $jointTr[0] $jointTr[1] $jointTr[2];
		setAttr ($source + "_Block.r")  $jointRt[0] $jointRt[1] $jointRt[2];
		setAttr ($source + "_Block.s")  $jointSc[0] $jointSc[1] $jointSc[2];
	}	
	//예전 버전에 Root가 들어가 있어서,,,	
	string $ver;		
	if ( `objExists ($target +  "_Line1_Zero.r" )` ) 
		$ver = "_Line";	
	else if ( `objExists ($target +  "_Root_Line1_Zero.r" )` )
		$ver = "_Root_Line";	
	
	//match zero
	for ($i = 1 ; $i <= 5 ; ++$i ) {	
			if ( `objExists ($target +  $ver + $i + "_Zero.r" )` ) {
				float $zeroRot[] = `getAttr ($target +  $ver + $i + "_Zero.r" )`;	
				if ( $mirrorX ) 
					setAttr ($source +  $ver + $i + "_Zero.r" ) $zeroRot[0] (-$zeroRot[1]) (-$zeroRot[2]); 
				else 
					setAttr ($source +  $ver + $i + "_Zero.r" ) $zeroRot[0] $zeroRot[1] $zeroRot[2]; 	
			}	
		}
		
	select ( $source + "_Block" );
	print ("//result :  match done.\n");
}

// hairChain에 constraint가 있을 경우 highlevel컨트롤러가 바디를 따라가는 걸로 인식하고 
// followBodyCon attribute를 추가한다.
global proc connectBodyFollowCon(){
    string $selLine5[] = `ls -sl "*_Line5*"`;
    for ($cur5 in $selLine5 ) {
        
        string $tokenTemp[];
        tokenize $cur5 "_" $tokenTemp;
		//zero constraint 만 찾아서.
        string $listCons[] = `ls ($tokenTemp[0] + "_*_Zero_parentConstraint*")`;
        
        //해당 line5 컨트롤러에 connecAttr가 없을 경우 만들어줍니다.
        if (size($listCons) > 0 && !`objExists ($cur5 + ".followBodyCon")`) {
             if (!`objExists ($cur5 + ".extraCon")`) {
                 addAttr -ln "extraCon" -at "enum" -en "▼:"  $cur5;
                 setAttr -e -channelBox true ($cur5 + ".extraCon");
             }
             addAttr -ln "followBodyCon" -k 1 -at "bool" $cur5;
        
        }
        
        for ($curPar in $listCons)
        {
			//3번까지 connect. 원래 연결이 있으면 끊고 다시 연결.
			for ($i=0 ; $i <= 3 ; $i++ ) {
				if ( `objExists ($curPar + ".w" + $i)`) {
					string $con[] = `listConnections -s 1 -d 0 -p 1 ($curPar + ".w" + $i)`;
					if ( size($con) > 0 )
						disconnectAttr $con[0] ($curPar + ".w" + $i);		   
					connectAttr -f ($cur5 + ".followBodyCon")($curPar + ".w" + $i); 
					print ("//result : connect " + $curPar + ".w" + $i + "\n");
				}
			}
        }
        
    }    
}


// hairSystem constraint 연결.
// 연결할 hairSystem을 선택하고 , 
// connectHairConstraint "연결할 constriantShape" "pinID" 실행.
global proc connectHairConstraint( string $constriant , int $num) {
	string $list[] = `ls -sl`;
	for ( $curSel in $list ) {
		string $tokenTemp[];
		tokenize $curSel "_" $tokenTemp;
		string $pre = $tokenTemp[0];
		connectAttr -f ( $constriant + ".outPin[0]" ) ($pre + "_Line_hairSystemShape.inputHairPin[" + $num + "]");
	}
}

//ex)connectHairConstraint hairConstraint_pinTailShape 8;

//get Hair connection ID
//hairConstraint shape을 선택하고 실행.
//cmd print
global proc printHairConsConnectID(){
	string $CMD;
	string $hairCons[] = `ls -type "hairConstraint" -sl`;

	for ($curHairCon in $hairCons ) {
		string $tokenTemp[];
		string $connection[] = `listConnections -d 1 -p 1 ($curHairCon + ".outPin[0]")`;
		tokenize $connection[0] "[]" $tokenTemp;
		print ( "connectHairConstraint " + $curHairCon + " " + $tokenTemp[1] + ";\n");

	}
}


global proc parentConsBatch(){
    string $list[] = `ls -sl`;
    for ($i = 1; $i < size($list) ; $i++ )
        parentConstraint -mo $list[0] $list[$i];
}

global proc addZeroTransform(){

    string $ls[] = `ls -sl`;
    
    string $text = "zero";
    string $result = `promptDialog
        -title "zero transform"
        -message "Enter Name:"
        -tx $text
        -button "OK" -button "Cancel"
        -defaultButton "OK" -cancelButton "Cancel"
        -dismissString "Cancel"`;
    
    if ($result == "OK") {
        $text = `promptDialog -query -text`;
        
        for ( $cur in $ls ) {
        string $dup[] =`duplicate -po -n ($cur + "_" + $text ) $cur`;
        parent $cur $dup[0];
        } 
    }
}   
    

// buildPose 만들기--------------------------------------------------
global proc b1setBuildPose() {

if(`objExists buildPose`){
    print "buildPose node already exist";
}
else {
    createNode -n "buildPose" dagPose;
    addAttr -ln udAttr -dt "string"  ("buildPose");		
}
			
select `sets -q ("ControlSet")`;				
string $controlSetMembers[]=`ls -sl`;				
string $setAttrCmd;				
for ($i=0;$i<size($controlSetMembers);$i++)				
	{			
	$tempString=`listAttr -k $controlSetMembers[$i]`;			
	for ($y=0;$y<size($tempString);$y++)			
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";		
	}			
setAttr -type "string" ("buildPose.udAttr") $setAttrCmd;				
}

// delete all key
global proc b1deleteAllKey() {
string $ccList[] = `sets -q "ControlSet"`;
cutKey -clear -time ":" -hierarchy none -controlPoints 0 -shape 1 $ccList;
}

// set noneKeyable attributes
global proc b1beforeRelease() {


if ( `objExists "Sub.facialControlVis"`)
	setAttr "Sub.facialControlVis" 1;
if ( `objExists "Sub.lodVis"`)
	setAttr "Sub.lodVis" 1;	
if ( `objExists "Sub.geometryVis"`)
	setAttr "Sub.geometryVis" 2;
if ( `objExists "MotionSystem.visibility"`)
	setAttr "MotionSystem.visibility" 1;
if ( `objExists "Sub.extraControlVis"`)
	setAttr "Sub.extraControlVis" 1;

if(`objExists eyeControl_GRP`)
	setAttr eyeControl_GRP.v 0 ;



//leg skinPose
string $legParts[] = { "IKLeg_L" , "IKLeg_R" , "PoleLeg_L" , "PoleLeg_R" , "FKIKLeg_R" , "FKIKLeg_L" , "FKAnkle_L" , "FKAnkle_R" , "FKKnee_R" , "FKKnee_L" , "FKHip_L" , "FKHip_R" };

for ($curCC in $legParts ) 
{
	if (`objExists ( $curCC + ".skinPose" )`)
		setAttr ( $curCC + ".skinPose" ) 0;
}    

b1JointVisMaya2014 0;
asGoToBuildPose bodySetup;


//namespace check
string $nsList[] = `namespaceInfo -listOnlyNamespaces ":"`;
if ( size ($nsList) > 2 ){
	NamespaceEditor;
    warning " namespace exist!! ";
}


}

// 선택한 mesh의 namespace return
global proc string getNSfromSel(){
	string $ns;
	string $sel[] = `ls -sl -head 1`;
	
	if ( size($sel) == 0 )
		error "please select something!!";
	
	string $tokenTemp[];
	int $tokenSize = `tokenize $sel[0] ":" $tokenTemp`;
	
	if ( $tokenSize == 2 )
		$ns = $tokenTemp[0];
	else if ( $tokenSize > 2 )
	    error "more Than two namespace. please set less than one namespace.";
	else    
	    $ns = ":";		
	return $ns; 	

}

// make Tpose / buildPose / legExcept
global proc b1goTpose( int $val , int $leg)
{
	string $curNS = `getNSfromSel`;
	string $listControl[] = `sets -q ($curNS + ":ControlSet")`;	

	string $legParts[] = { "IKLeg_L" , "IKLeg_R" , "PoleLeg_L" , "PoleLeg_R" , "FKIKLeg_R" , "FKIKLeg_L" , "FKAnkle_L" , "FKAnkle_R" , "FKKnee_R" , "FKKnee_L" , "FKHip_L" , "FKHip_R" };

	int $value = (10 * $val);
	for ($curCon in $listControl)
		if (`objExists ($curCon + ".skinPose")`)
			setAttr ($curCon + ".skinPose") $value;
	if ( $leg == 1 ){
		for ($curCC in $legParts ) 
			if (`objExists ( $curNS + ":" + $curCC + ".skinPose" )`)
				setAttr ( $curNS + ":" + $curCC + ".skinPose" ) 0;	
	}			
}





global proc getJointList() {
	
	string $listSel[] = `ls -sl`;
	string $temp[];
	string $jointList[];
	
	for ( $curSel  in $listSel ) {
		$temp = `listRelatives -c -s $curSel`;
		string $curShape = $temp[0];
		$temp = `listConnections -s 1 -t "skinCluster" $curShape`;
		string $skinCluster = $temp[0];		
		string $curjointList[] = `listConnections -s 1 -t "joint" $skinCluster`;
		appendStringArray($jointList, $curjointList, size($curjointList));		
	}	
	$jointList = stringArrayRemoveDuplicates($jointList);
	select $jointList;
	//skinCluster -mi 1 -dr 4.5 -tsb $jointList $targetMesh;		
}

global proc copySkinFromPartialMesh(string $targetMesh) {
	string $mesh[] = `ls -sl`;

	select -r $mesh[0];
	PolySelectConvert 3;
	string $allVerts[] = `ls -sl -fl`;

	string $targetVers[];
	string $targetShape[] = `listRelatives -s -c $targetMesh`;

	for ( $i=0 ; $i < size($allVerts) ; ++$i ) {
	//vertexInfo
		float $position[] = `pointPosition -w $allVerts[$i]`;	

		string $node = `createNode "closestPointOnMesh"`;				
		setAttr ($node + ".inPosition") $position[0] $position[1] $position[2];
		connectAttr -f ($targetShape[0] + ".outMesh") ($node + ".inMesh");		
		int $num = `getAttr ($node + ".closestVertexIndex")`;
		$targetVers[$i] = ($targetMesh + ".vtx[" + $num + "]");
		delete $node;

	}	

	select -r $mesh[0];
	select -add $targetVers;
	CopySkinWeights;

}

global proc b1insertLayer( string $name){
	//선택된것들을 layer에 넣음.
	string $sel[] = `ls -sl`;
	
	if ( !`objExists $name`)
		createNode -n $name displayLayer;
		
	editDisplayLayerMembers -noRecurse $name $sel;
}
//geomety와 Geometry 하위의 모든 transform을 geoLayer에 넣어주고.
//SubControl과 연결해준다.
global proc b1InsetGeoLayer(){
	string $geometry[] = `listRelatives -c -ad -type "transform" "geometry" "Geometry"`;

	if ( !`objExists "geoLayer"`)
			createNode -n "geoLayer" displayLayer;
	
	string $expCon[] = `listConnections -s 1 -t "expression" "geoLayer"`;
	string $geoVisCon;
	if (`objExists "Sub.geometryVis"`)
		$geoVisCon = "Sub.geometryVis";
	else if	(`objExists "Main.geometryVis"`)	
		$geoVisCon = "Main.geometryVis";
		
	if (!`objExists $expCon[0]`&&`objExists $geoVisCon`)		
		expression -s ("if (" + $geoVisCon + " == 0) \n\tgeoLayer.displayType = 0;\nelse if (" + $geoVisCon + " == 1) \n\tgeoLayer.displayType = 1;\nelse \n\tgeoLayer.displayType = 2;")  -o "" -n "exp_geoLayer" -ae 1 -uc all ;
	
	editDisplayLayerMembers -noRecurse "geoLayer" $geometry;
}	

global proc b1JointVisMaya2014 (int $onOff)
{
string $joints[];
if (!`objExists "root"`){
	string $list[] = `ls -sl -head 1`;
	string $tokenTemp[];
	int $tokenSize = `tokenize $list[0] ":" $tokenTemp`;
	if ( `objExists ($tokenTemp[0] + ":root")`)
		$joints =`listRelatives -type joint -ad ($tokenTemp[0] + ":root")`;
	else
		return;		
}
else	
	$joints =`listRelatives -type joint -ad root`;
	
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asGoToBuildPose (string $uiName)
{
int $ctrlButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
string $nameSpace;
string $controlSets[];
if ($uiName=="bodySetup")
	{
	$nameSpace="";
	$controlSets[0]="ControlSet";
	}
else if ($uiName=="faceSetup")
	{
	$nameSpace="";
	$controlSets[0]="FaceControlSet";
	}
else
	{
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
	$controlSets=`asGetControlSetsFromUI $uiName`;
	}
if ($nameSpace==":")
	$nameSpace="";

string $buildPose="buildPose";
if (`gmatch $controlSets[0] "*FaceControlSet"`)
    $buildPose="faceBuildPose";

string $tempString[],$tempString2[],$buffer[];
string $setAttrCmd,$cmd;


$setAttrCmd=`getAttr ($nameSpace+$buildPose+".udAttr")`;
tokenize $setAttrCmd ";" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	$cmd=$tempString[$y];
	if ($nameSpace!="")
		{
		tokenize $cmd $buffer;
		if (`gmatch $cmd "xform*"`)
			$substituteWordNr=size($buffer)-1;
		else
			$substituteWordNr=1;
		$cmd="";
		for ($z=0;$z<size($buffer);$z++)
			{
			if ($z==$substituteWordNr)
				$cmd+=$nameSpace;
			$cmd+=$buffer[$z]+" ";
			}
		}
	if ($ctrlButton)
		if (`gmatch $cmd "*Main.*"`)
			continue;
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

//run
string $run,$fitTopNode,$cmd,$objAttr;
for ($i=0;$i<size($controlSets);$i++)
	{
	if (`gmatch $controlSets[$i] "*ControlSet"`)
		if (`objExists ($nameSpace+"FitSkeleton")`)
			$fitTopNode=$nameSpace+"FitSkeleton";
	if (`gmatch $controlSets[$i] "*FaceControlSet"`)
		$fitTopNode=($nameSpace+"FaceFitSkeleton");
	}

if (`objExists $fitTopNode`)
	if (`attributeExists "run" $fitTopNode`)
		{
		$run=`getAttr ($fitTopNode+".run")`;
		if ($nameSpace=="")
			catch (`evalEcho ($run)`);
		else
			{
			tokenize $run ";" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				tokenize $tempString[$i] $tempString2;
				$objAttr=`substitute "\"" $tempString2[1] ""`;
				$objAttr=`substitute "\"" $objAttr ""`;
				$cmd=$tempString2[0]+" "+$nameSpace+$objAttr+" "+$tempString2[2]+";";
				catch (`evalEcho ($cmd)`);
				}
			}
		}
}

global proc b1ExportLod03FromRig() {
//export lod03 form rig
source "C:/Program Files/Autodesk/Maya2014/scripts/startup/channelBoxCommand.mel";

if (!`objExists "lod03_GRP"`)
    error "lod03_GRP not exist.";

//layer
select "lod03_GRP";
select -hi;
string $listAll[] = `ls -sl -typ "mesh"`;
//layer
editDisplayLayerMembers -noRecurse "defaultLayer" $listAll;

string $list[] = `ls -sl -typ "mesh"`;
//constraint
delete -constraints;

//expression
CBdeleteConnection "lod03_GRP.v";
CBdeleteConnection "geometry.v";

//blendshape
string $temp[];
for ($cur in $list ) {
    $temp = `listConnections -s 1 -t "blendShape" ($cur + ".inMesh")`;
    if (`objExists $temp[0]`)
        delete $temp[0];
}        
        
//history
select "lod03_GRP";
select -hi;
DeleteHistory;

string $listShape[] = `listRelatives -ad -c -typ "mesh" "lod03_GRP"`;

for ($curShape in $listShape ){
    if (`getAttr ($curShape + ".intermediateObject")`){
        delete $curShape;
        print ("//delete : " + $curShape + "\n"); 
    }
} 
		
//unlock
string $unlockList[] = `listRelatives -ad -c -type "transform" "lod03_GRP"`;
$unlockList[size($unlockList)] = "lod03_GRP";
for ($curMesh in $unlockList)
   	b1unLock $curMesh;		
		
//delete Layer
if (`objExists "geoLayer"`)
	delete "geoLayer";
		
//delete rig
 if (`objExists "rig"`)
    delete "rig";
    

setAttr "lod03_GRP.visibility" 1;	
select "lod03_GRP" "set";  
select -add -ne set ;
    
}

//lod02_shader assign tool.
//material 선택하고 적용할 texure를 선택한 뒤 실행.
global proc b1addlod02Tex(){

    string $selMT[] = `ls -sl`;
    string $tex = $selMT[1];
    
    string $SG[] = `listConnections -d 1 -s 0 ($selMT[0] + ".outColor")`;
    string $lsShape[] = `sets -q $SG[0]`;
    
    //make lambert
    string $lambMT = `shadingNode -asShader lambert`;
    string $lambSG = `sets -renderable true -noSurfaceShader true -empty -n ($lambMT + "SG")`;
    connectAttr -f ($lambMT + ".outColor") ($lambSG+ ".surfaceShader");
    connectAttr -force ($tex + ".outColor") ($lambMT + ".color");
    
    
    for ($curShape in $lsShape )
        if (`gmatch $curShape "lod02_*"`)
            sets -e -forceElement $lambSG $curShape;
    

}



global proc deleteIntermediateMesh(){
    string $curSel[] = `ls -sl -head 1`;
    string $listShape[] = `listRelatives -ad -c -f -typ "mesh" $curSel[0]`;
    for ($curShape in $listShape ){
        if (`getAttr ($curShape + ".intermediateObject")`){
            delete $curShape;
            print ("//delete : " + $curShape + "\n"); 
        }
    } 
}

//facial
// facial control position mirror copy
global proc b1mirrorfacialCC()
{
    string $listJoint[] = `ls -sl`;
    
    for ( $curJoint in $listJoint) {
        string $side;
        string $otherSide;
		$side = `substring $curJoint (size($curJoint)-1) (size($curJoint))`;
		
        if( $side == "_L" )
            $otherSide = "_R";
        else if( $side == "_R" )
            $otherSide = "_L";
        else
            continue;
            
        string $otherSideJoint = `substitute $side $curJoint $otherSide`;     
            
        float $jointTr[] = `getAttr ($curJoint + ".t")`;
        float $jointRt[] = `getAttr ($curJoint + ".r")`;
        setAttr ($otherSideJoint + ".t") (-$jointTr[0]) (-$jointTr[1]) (-$jointTr[2]);
        setAttr ($otherSideJoint + ".r")  $jointRt[0] $jointRt[1] $jointRt[2];
        
    }

}

// joint position mirror copy
global proc b1mirrorJointPositioin()
{
    string $listJoint[] = `ls -sl`;
    
    for ( $curJoint in $listJoint) {
        string $side;
        string $otherSide;
        if( `gmatch $curJoint "*_L"` )
        {
            $side = "_L";
            $otherSide = "_R";
        }    
        else if( `gmatch $curJoint "*_R"` )       
        {
            $side = "_R";
            $otherSide = "_L";
        }
        else
            continue;
            
        string $otherSideJoint = `substitute $side $curJoint $otherSide`;     
            
        float $jointTr[] = `getAttr ($curJoint + ".t")`;
        float $jointRt[] = `getAttr ($curJoint + ".r")`;
        setAttr ($otherSideJoint + ".t") (-$jointTr[0]) $jointTr[1] $jointTr[2];
        setAttr ($otherSideJoint + ".r")  $jointRt[0] $jointRt[1] $jointRt[2];
        
    }

}





// center에 있는 cluster 값  mirror하기.
// mesh 선택하고 cluster 선택.
global proc b1mirrorCenterCluster() {

string $listSel[] = `ls -sl`;
string $mesh = $listSel[0];
string $meshShape[] = `listRelatives -s -c $mesh`;
string $clusterHandle = $listSel[1]; 
string $clusters[] = `listConnections -type "cluster" $clusterHandle`;
string $cluster = $clusters[0];

//get cluster members
		string $clusterSets[] = `listConnections -type "objectSet" $cluster`;
		string $components[] = `sets -q $clusterSets[0]`;
		string $members[] = `filterExpand -sm 28 -sm 31 -sm 36 -sm 46 $components`;
		
	for ( $vertex in $members) {		
		//vertexInfo
		float $position[] = `pointPosition -l $vertex`;
		
		if ( $position[0] > 0 ) {	
		
		float $curVal[] = `percent -q -v $cluster $vertex`;		
		
		string $node = `createNode "closestPointOnMesh"`;				
		setAttr ($node + ".inPosition") (-$position[0]) $position[1] $position[2];
		connectAttr -f ($meshShape[0] + ".outMesh") ($node + ".inMesh");
		
		int $num = `getAttr ($node + ".closestVertexIndex")`;
		string $newPoint = ($mesh + ".vtx[" + $num + "]");	
		delete $node;
		
		int $found = stringArrayContains($newPoint, $members);
				
		if ($found == 0)
			sets -add  $clusterSets $newPoint; 
					
		percent -v $curVal[0] $cluster $newPoint;
				
		}
		
	}
	
}


// blenshape sort해서 넣기.
global proc sortBlendShape( ){
	print ("*** sort blendShape ***\n");	
    string $selList[] = `ls -sl`; 
	int $lastIndex = size($selList)-1;
	string $target = $selList[$lastIndex];
	stringArrayRemoveAtIndex($lastIndex, $selList);	
    string $sort[] = sort( $selList );
	blendShape -foc $selList $target;
	print ("*** sort blendShape to " + $target + "done.***\n");	
}


// 순서대로 blendShape
global proc blendShapeGroup()
{    
    string $list[] = `ls -sl`;    
    for ( $i = 0 ; $i <= size($list) ; $i = $i+2 )
    {    
		if ( `objExists $list[$i]` &&  `objExists $list[($i+1)]` ) {
			string $blendShapeNode[] = `blendShape -frontOfChain $list[$i] $list[($i+1)]`;    	
			setAttr ($blendShapeNode[0] + "." + $list[$i]) 1; 
			print ("//result : " + $list[$i] + " >> " + $list[($i+1)] + " are connected.\n ") ;
		}
	}
}	


// blendShape의 target mesh를 만들어준다.
// blendShape node 선택하고
// copy하고 싶은 shape group을 선택하고 실행.

global proc b1makeBStargetMesh (){

	string $sel[] = `ls -sl`;
	string $blendShape;
	string $copyMesh;
	
	if ( !(`objectType $sel[0]` == "blendShape") ) 
		error "select blendShape node first";
	else 
		 $blendShape = $sel[0];
		 
	if ( !(`objectType $sel[1]` == "transform") ) 
		error "select copy mesh or group second";
	else 
		 $copyMesh = $sel[1];	
		
	string $listTargets[] = `listAttr -m ($blendShape + ".w")`;	

	int $i = 1;
	for ( $curBS in $listTargets ) {	            
        if( $curBS != "fix_model_eyelash")
        {
           	setAttr ($blendShape + "." + $curBS) 1;
    		string $dupMesh[] = `duplicate -rr -renameChildren -n ("BS_" + $curBS) $copyMesh`;
    		xform -r -t ($i * 30 ) 0 0 $dupMesh[0];
    		setAttr ($blendShape + "." + $curBS) 0;
		}
	}

}
  

// facial BS connection mel
// facial expression 
global proc connecFacialDriver(  float $dvS , float $valS ,float $dvF , float $valF , string $driver , string $driven )
{
	if (`objExists $driver` && `objExists $driven`) {	
		setDrivenKeyframe -itt linear -ott linear -dv $dvS -v $valS -currentDriver $driver $driven;
		setDrivenKeyframe -itt linear -ott linear -dv $dvF -v $valF -currentDriver $driver $driven;
		//print ( $driver  + " and "  + $driven + " are connected. \n");	
	}
	else {
		print ( "**** " + $driver  + " or "  + $driven + " not exists. \n");	
	}	
}

// connect blendshape
global proc b1connectFacialControl (string $type){


	if ( $type == "basic" ) {
		// eyebrows
		//L
		connecFacialDriver 0 0 3 1 "eyebrows_SliderL_Ctrl.translateY" "blendShape2.eyebrows_surprise_L";
		connecFacialDriver 0 0 -3 1 "eyebrows_SliderL_Ctrl.translateY"  "blendShape2.eyebrows_angry_L";
		connecFacialDriver 0 0 6 1 "eyebrows_SliderL_Ctrl.eyebrowsSad"  "blendShape2.eyebrows_sad_L";
		connecFacialDriver 0 0 6 1 "eyebrows_SliderL_Ctrl.eyebrows_smile"  "blendShape2.eyebrows_smile_L";
		connecFacialDriver 0 0 3 1 "eyebrows_SliderL_Ctrl.eyebrowUpDown"  "blendShape2.eyebrows_moveUp_L";
		connecFacialDriver 0 0 -3 1 "eyebrows_SliderL_Ctrl.eyebrowUpDown"  "blendShape2.eyebrows_moveDown_L";


		//R
		connecFacialDriver 0 0 3 1 "eyebrows_SliderR_Ctrl.translateY" "blendShape2.eyebrows_surprise_R";
		connecFacialDriver 0 0 -3 1 "eyebrows_SliderR_Ctrl.translateY"  "blendShape2.eyebrows_angry_R";
		connecFacialDriver 0 0 6 1 "eyebrows_SliderR_Ctrl.eyebrowsSad"  "blendShape2.eyebrows_sad_R";
		connecFacialDriver 0 0 6 1 "eyebrows_SliderR_Ctrl.eyebrows_smile"  "blendShape2.eyebrows_smile_R";
		connecFacialDriver 0 0 3 1 "eyebrows_SliderR_Ctrl.eyebrowUpDown"  "blendShape2.eyebrows_moveUp_R";
		connecFacialDriver 0 0 -3 1 "eyebrows_SliderR_Ctrl.eyebrowUpDown"  "blendShape2.eyebrows_moveDown_R";

		// Eyes
		//L
		connecFacialDriver 0 0 3 1 "Eyelid_SliderL_Ctrl.translateY" "blendShape2.eye_big_L";
		connecFacialDriver 0 0 -3 1 "Eyelid_SliderL_Ctrl.translateY" "blendShape2.eye_blink_L";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderL_Ctrl.squeent" "blendShape2.eye_squeent_L";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderL_Ctrl.smile" "blendShape2.eye_smile_L";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderL_Ctrl.sad"  "blendShape2.eye_sad_L";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderL_Ctrl.liftUnderEyelid" "blendShape2.eye_underEyelid_L";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderL_Ctrl.downUpperEyelid" "blendShape2.eye_upperEyelid_L";

		//R
		connecFacialDriver 0 0 3 1 "Eyelid_SliderR_Ctrl.translateY" "blendShape2.eye_big_R";
		connecFacialDriver 0 0 -3 1 "Eyelid_SliderR_Ctrl.translateY" "blendShape2.eye_blink_R";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderR_Ctrl.squeent" "blendShape2.eye_squeent_R";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderR_Ctrl.smile" "blendShape2.eye_smile_R";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderR_Ctrl.sad"  "blendShape2.eye_sad_R";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderR_Ctrl.liftUnderEyelid" "blendShape2.eye_underEyelid_R";
		connecFacialDriver 0 0 6 1 "Eyelid_SliderR_Ctrl.downUpperEyelid" "blendShape2.eye_upperEyelid_R";

		// mouth
		//L
		connecFacialDriver 0 0 3 1 "smile_BoxL_Ctrl.translateY" "blendShape2.mouth_smile_L";
		connecFacialDriver 0 0 -3 1 "smile_BoxL_Ctrl.translateY" "blendShape2.mouth_frown_L";
		connecFacialDriver 0 0 3 1 "smile_BoxL_Ctrl.translateX" "blendShape2.mouth_wide_L";
		connecFacialDriver 0 0 -3 1 "smile_BoxL_Ctrl.translateX" "blendShape2.mouth_narrow_L";

		//R
		connecFacialDriver 0 0 3 1 "smile_BoxR_Ctrl.translateY" "blendShape2.mouth_smile_R";
		connecFacialDriver 0 0 -3 1 "smile_BoxR_Ctrl.translateY" "blendShape2.mouth_frown_R";
		connecFacialDriver 0 0 3 1 "smile_BoxR_Ctrl.reverseX" "blendShape2.mouth_wide_R";
		connecFacialDriver 0 0 -3 1 "smile_BoxR_Ctrl.reverseX" "blendShape2.mouth_narrow_R";


		// openSmile
		//L
		connecFacialDriver 0 0 3 1 "openSmile_SliderL_Ctrl.translateY"  "blendShape2.mouth_smileOpen_L";
		connecFacialDriver 0 0 6 0 "openSmile_SliderL_Ctrl.translateY"  "blendShape2.mouth_smileOpen_L";
		connecFacialDriver 3 0 6 1 "openSmile_SliderL_Ctrl.translateY"  "blendShape2.mouth_smileBig_L";

		//R
		connecFacialDriver 0 0 3 1 "openSmile_SliderR_Ctrl.translateY"  "blendShape2.mouth_smileOpen_R";
		connecFacialDriver 0 0 6 0 "openSmile_SliderR_Ctrl.translateY"  "blendShape2.mouth_smileOpen_R";
		connecFacialDriver 3 0 6 1 "openSmile_SliderR_Ctrl.translateY"  "blendShape2.mouth_smileBig_R";

		// anger
		//L
		connecFacialDriver 0 0 3 1 "Anger_SliderL_Ctrl.translateY"  "blendShape2.mouth_angry_L";
		connecFacialDriver 0 0 6 0 "Anger_SliderL_Ctrl.translateY"  "blendShape2.mouth_angry_L";
		connecFacialDriver 3 0 6 1 "Anger_SliderL_Ctrl.translateY"  "blendShape2.mouth_angryBig_L";

		//R
		connecFacialDriver 0 0 3 1 "Anger_SliderR_Ctrl.translateY"  "blendShape2.mouth_angry_R";
		connecFacialDriver 0 0 6 0 "Anger_SliderR_Ctrl.translateY"  "blendShape2.mouth_angry_R";
		connecFacialDriver 3 0 6 1 "Anger_SliderR_Ctrl.translateY"  "blendShape2.mouth_angryBig_R";

		// jaw
		connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY""blendShape2.jaw_open_M";
		connecFacialDriver 0 0 3 1 "jaw_Box_Ctrl.translateX" "blendShape2.jaw_left_M";
		connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateX" "blendShape2.jaw_right_M";

		// mouthPosition move
		connecFacialDriver 0 0 3 1 "move_Box_Ctrl.translateY""blendShape2.mouth_moveUp_M";
		connecFacialDriver 0 0 -3 1 "move_Box_Ctrl.translateY""blendShape2.mouth_moveDown_M";
		connecFacialDriver 0 0 3 1 "move_Box_Ctrl.translateX" "blendShape2.mouth_moveLeft_M";
		connecFacialDriver 0 0 -3 1 "move_Box_Ctrl.translateX" "blendShape2.mouth_moveRight_M";

		// lipSync
		connecFacialDriver 0 0 3 1 "lipSync_Box_Ctrl.translateY""blendShape2.lipsync_a_M";
		connecFacialDriver 0 0 -3 1 "lipSync_Box_Ctrl.translateY""blendShape2.lipsync_e_M";
		connecFacialDriver 0 0 3 1 "lipSync_Box_Ctrl.translateX""blendShape2.lipsync_i_M";
		connecFacialDriver 0 0 -3 1 "lipSync_Box_Ctrl.translateX""blendShape2.lipsync_o_M";

		connecFacialDriver 0 0 6 1 "lipSync_Box_Ctrl.funnel" "blendShape2.mouth_funnel_M";
		connecFacialDriver 0 0 6 1 "lipSync_Box_Ctrl.liftUpperLip""blendShape2.mouth_upperLip_M";
		connecFacialDriver 0 0 6 1 "lipSync_Box_Ctrl.downUnderLip""blendShape2.mouth_underLip_M";
		connecFacialDriver 0 0 6 1 "lipSync_Box_Ctrl.suckUpperLip""blendShape2.mouth_suckUpperLip_M";
		connecFacialDriver 0 0 6 1 "lipSync_Box_Ctrl.suckUnderLip""blendShape2.mouth_suckUnderLip_M";


		// etc
		connecFacialDriver 0 0 3 1 "etc_Ctrl.cheekPuff"  "blendShape2.cheek_puff_M";
		connecFacialDriver 0 0 -3 1 "etc_Ctrl.cheekPuff"  "blendShape2.cheek_suck_M";

		connecFacialDriver 0 0 3 1 "etc_Ctrl.noseUp"  "blendShape2.nose_up_M";
	}

	if ( $type == "fix" ) {
	// fix smile
	//L
	string $multSmileL = `shadingNode -asUtility multiplyDivide`;
	connecFacialDriver 0 0 3 1 "openSmile_SliderL_Ctrl.translateY"  ($multSmileL + ".input1X");
	connecFacialDriver 0 0 6 0 "openSmile_SliderL_Ctrl.translateY"  ($multSmileL + ".input1X");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multSmileL + ".input2X");
	if ( `objExists "blendShape2.fix_smileOpen_L"`)
		connectAttr -f ($multSmileL + ".outputX") "blendShape2.fix_smileOpen_L";
		
	connecFacialDriver 3 0 6 1 "openSmile_SliderL_Ctrl.translateY"  ($multSmileL + ".input1Y");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multSmileL + ".input2Y");
	if ( `objExists "blendShape2.fix_smileBig_L"`)
		connectAttr -f ($multSmileL + ".outputY") "blendShape2.fix_smileBig_L";

	connecFacialDriver 0 0 3 1 "smile_BoxL_Ctrl.translateY"  ($multSmileL + ".input1Z");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multSmileL + ".input2Z");
	if ( `objExists "blendShape2.fix_smile_L"`)
		connectAttr -f ($multSmileL + ".outputZ") "blendShape2.fix_smile_L";

	//R
	string $multSmileR = `shadingNode -asUtility multiplyDivide`;
	connecFacialDriver 0 0 3 1 "openSmile_SliderR_Ctrl.translateY"  ($multSmileR + ".input1X");
	connecFacialDriver 0 0 6 0 "openSmile_SliderR_Ctrl.translateY"  ($multSmileR + ".input1X");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multSmileR + ".input2X");
	if ( `objExists "blendShape2.fix_smileOpen_R"`)
		connectAttr -f ($multSmileR + ".outputX") "blendShape2.fix_smileOpen_R";

	connecFacialDriver 3 0 6 1 "openSmile_SliderR_Ctrl.translateY"  ($multSmileR + ".input1Y");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multSmileR + ".input2Y");
	if ( `objExists "blendShape2.fix_smileBig_R"`)
		connectAttr -f ($multSmileR + ".outputY") "blendShape2.fix_smileBig_R";

	connecFacialDriver 0 0 3 1 "smile_BoxR_Ctrl.translateY"  ($multSmileR + ".input1Z");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multSmileR + ".input2Z");
	if ( `objExists "blendShape2.fix_smile_R"`)
		connectAttr -f ($multSmileR + ".outputZ") "blendShape2.fix_smile_R";


	// fix anger
	// L
	string $multAngryL = `shadingNode -asUtility multiplyDivide`;
	connecFacialDriver 0 0 3 1 "Anger_SliderL_Ctrl.translateY"  ($multAngryL + ".input1X");
	connecFacialDriver 0 0 6 0 "Anger_SliderL_Ctrl.translateY"  ($multAngryL + ".input1X");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multAngryL + ".input2X");
	if ( `objExists "blendShape2.fix_angry_L"`)
		connectAttr -f ($multAngryL + ".outputX") "blendShape2.fix_angry_L";

	connecFacialDriver 3 0 6 1 "Anger_SliderL_Ctrl.translateY"  ($multAngryL + ".input1Y");
	connecFacialDriver 0 0 -3 1 "Anger_SliderL_Ctrl.translateY"  ($multAngryL + ".input2Y");
	if ( `objExists "blendShape2.fix_angryBig_L"`)
		connectAttr -f ($multAngryL + ".outputY") "blendShape2.fix_angryBig_L";

	connecFacialDriver 0 0 -3 1 "smile_BoxL_Ctrl.translateY"  ($multAngryL + ".input1Z");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multAngryL + ".input2Z");
	if ( `objExists "blendShape2.fix_frown_L"`)
		connectAttr -f ($multAngryL + ".outputZ") "blendShape2.fix_frown_L";

	// R
	string $multAngryR = `shadingNode -asUtility multiplyDivide`;
	connecFacialDriver 0 0 3 1 "Anger_SliderR_Ctrl.translateY"  ($multAngryR + ".input1X");
	connecFacialDriver 0 0 6 0 "Anger_SliderR_Ctrl.translateY"  ($multAngryR + ".input1X");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multAngryR + ".input2X");
	if ( `objExists "blendShape2.fix_angry_R"`)
		connectAttr -f ($multAngryR + ".outputX") "blendShape2.fix_angry_R";

	connecFacialDriver 3 0 6 1 "Anger_SliderR_Ctrl.translateY"  ($multAngryR + ".input1Y");
	connecFacialDriver 0 0 -3 1 "Anger_SliderR_Ctrl.translateY"  ($multAngryR + ".input2Y");
	if ( `objExists "blendShape2.fix_angryBig_R"`)
		connectAttr -f ($multAngryR + ".outputY") "blendShape2.fix_angryBig_R";

	connecFacialDriver 0 0 -3 1 "smile_BoxR_Ctrl.translateY"  ($multAngryR + ".input1Z");
	connecFacialDriver 0 0 -3 1 "jaw_Box_Ctrl.translateY"  ($multAngryR + ".input2Z");
	if ( `objExists "blendShape2.fix_frown_R"`)
		connectAttr -f ($multAngryR + ".outputZ") "blendShape2.fix_frown_R";

	}

	// eyeAim Setup 
	if ( $type == "eyeAim" ) {
	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_L.rotateY irisPlace_L_aim_grp.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv -25 -v -.2 -currentDriver Eye_L.rotateY irisPlace_L_aim_grp.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv 25 -v .2 -currentDriver Eye_L.rotateY irisPlace_L_aim_grp.translateX;

	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_L.rotateZ irisPlace_L_aim_grp.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv -20 -v -0.2 -currentDriver Eye_L.rotateZ irisPlace_L_aim_grp.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv 20 -v 0.2 -currentDriver Eye_L.rotateZ irisPlace_L_aim_grp.translateY;


	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_R.rotateY irisPlace_R_aim_grp.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv -25 -v -.2 -currentDriver Eye_R.rotateY irisPlace_R_aim_grp.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv 25 -v .2 -currentDriver Eye_R.rotateY irisPlace_R_aim_grp.translateX;

	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_R.rotateZ irisPlace_R_aim_grp.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv -20 -v -0.2 -currentDriver Eye_R.rotateZ irisPlace_R_aim_grp.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv 20 -v 0.2 -currentDriver Eye_R.rotateZ irisPlace_R_aim_grp.translateY;

	//eye Setup
	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_BoxL_Ctrl.translateX irisPlace_L_scale.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv -3 -v -.2 -currentDriver Eye_BoxL_Ctrl.translateX irisPlace_L_scale.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv 3 -v .2 -currentDriver Eye_BoxL_Ctrl.translateX irisPlace_L_scale.translateX;

	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_BoxL_Ctrl.translateY irisPlace_L_scale.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv 3 -v .2 -currentDriver Eye_BoxL_Ctrl.translateY irisPlace_L_scale.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv -3 -v -.2 -currentDriver Eye_BoxL_Ctrl.translateY irisPlace_L_scale.translateY;


	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_BoxR_Ctrl.translateX irisPlace_R_scale.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv -3 -v -.2 -currentDriver Eye_BoxR_Ctrl.translateX irisPlace_R_scale.translateX;
	setDrivenKeyframe -itt linear -ott linear -dv 3 -v .2 -currentDriver Eye_BoxR_Ctrl.translateX irisPlace_R_scale.translateX;

	setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver Eye_BoxR_Ctrl.translateY irisPlace_R_scale.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv 3 -v .2 -currentDriver Eye_BoxR_Ctrl.translateY irisPlace_R_scale.translateY;
	setDrivenKeyframe -itt linear -ott linear -dv -3 -v -.2 -currentDriver Eye_BoxR_Ctrl.translateY irisPlace_R_scale.translateY;

	}

	// pupil size
	if ( $type == "pupil" ) {
	addAttr -e -minValue -3 -maxValue 3 "Eye_BoxR_Ctrl.pupilScaleY";
	addAttr -e -minValue -3 -maxValue 3 "Eye_BoxL_Ctrl.pupilScaleY";

	connecFacialDriver 0 1 3 1.3 "Eye_BoxL_Ctrl.pupilSize""irisPlace_L_scale.scaleX";
	connecFacialDriver 0 1 -3 0.5 "Eye_BoxL_Ctrl.pupilSize""irisPlace_L_scale.scaleX";
	connecFacialDriver 0 1 3 1.3 "Eye_BoxL_Ctrl.pupilSize""irisPlace_L_scale.scaleY";
	connecFacialDriver 0 1 -3 0.5 "Eye_BoxL_Ctrl.pupilSize""irisPlace_L_scale.scaleY";
	connecFacialDriver 0 1 3 1.3 "Eye_BoxL_Ctrl.pupilSize""irisPlace_L_scale.scaleZ";
	connecFacialDriver 0 1 -3 0.5 "Eye_BoxL_Ctrl.pupilSize""irisPlace_L_scale.scaleZ";
	connecFacialDriver 0 1 -3 .5 "Eye_BoxL_Ctrl.pupilScaleY""irisPlace_L_scale_GRP.scaleY";
	connecFacialDriver 0 1 3 1.5 "Eye_BoxL_Ctrl.pupilScaleY""irisPlace_L_scale_GRP.scaleY";


	connecFacialDriver 0 1 3 1.3 "Eye_BoxR_Ctrl.pupilSize""irisPlace_R_scale.scaleX";
	connecFacialDriver 0 1 -3 0.5 "Eye_BoxR_Ctrl.pupilSize""irisPlace_R_scale.scaleX";
	connecFacialDriver 0 1 3 1.3 "Eye_BoxR_Ctrl.pupilSize""irisPlace_R_scale.scaleY";
	connecFacialDriver 0 1 -3 0.5 "Eye_BoxR_Ctrl.pupilSize""irisPlace_R_scale.scaleY";
	connecFacialDriver 0 1 3 1.3 "Eye_BoxR_Ctrl.pupilSize""irisPlace_R_scale.scaleZ";
	connecFacialDriver 0 1 -3 0.5 "Eye_BoxR_Ctrl.pupilSize""irisPlace_R_scale.scaleZ";
	connecFacialDriver 0 1 -3 0.5 "Eye_BoxR_Ctrl.pupilScaleY""irisPlace_R_scale_GRP.scaleY";
	connecFacialDriver 0 1 3 1.5 "Eye_BoxR_Ctrl.pupilScaleY""irisPlace_R_scale_GRP.scaleY";

	}

	if ( $type == "BallEye" ) {
		//eye Setup for rotation Eye
		connecFacialDriver 0 0 3 25 "Eye_BoxR_Ctrl.translateX" "FKExtraEye_R.rotateY";
		connecFacialDriver 0 0 -3 -25 "Eye_BoxR_Ctrl.translateX" "FKExtraEye_R.rotateY";

		connecFacialDriver 0 0 3 25 "Eye_BoxR_Ctrl.translateY" "FKExtraEye_R.rotateZ";
		connecFacialDriver 0 0 -3 -25 "Eye_BoxR_Ctrl.translateY" "FKExtraEye_R.rotateZ";


		connecFacialDriver 0 0 3 25 "Eye_BoxL_Ctrl.translateX" "FKExtraEye_L.rotateY";
		connecFacialDriver 0 0 -3 -25 "Eye_BoxL_Ctrl.translateX" "FKExtraEye_L.rotateY";

		connecFacialDriver 0 0 3 25 "Eye_BoxL_Ctrl.translateY" "FKExtraEye_L.rotateZ";
		connecFacialDriver 0 0 -3 -25 "Eye_BoxL_Ctrl.translateY" "FKExtraEye_L.rotateZ";

		/* /pupilSize for rotation Eye with texturePlace
		connecFacialDriver 0 1 3 .5 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.repeatU";
		connecFacialDriver 0 1 3 .5 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.repeatV";
		connecFacialDriver 0 0 3 .25 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.offsetU";
		connecFacialDriver 0 0 3 .25 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.offsetV";

		connecFacialDriver 0 1 -3 2 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.repeatU";
		connecFacialDriver 0 1 -3 2 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.repeatV";
		connecFacialDriver 0 0 -3 -.5 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.offsetU";
		connecFacialDriver 0 0 -3 -.5 "Eye_BoxL_Ctrl.pupilSize" "eyeball_L_iris_place.offsetV";


		connecFacialDriver 0 1 3 .5 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.repeatU";
		connecFacialDriver 0 1 3 .5 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.repeatV";
		connecFacialDriver 0 0 3 .25 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.offsetU";
		connecFacialDriver 0 0 3 .25 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.offsetV";

		connecFacialDriver 0 1 -3 2 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.repeatU";
		connecFacialDriver 0 1 -3 2 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.repeatV";
		connecFacialDriver 0 0 -3 -.5 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.offsetU";
		connecFacialDriver 0 0 -3 -.5 "Eye_BoxR_Ctrl.pupilSize" "eyeball_R_iris_place.offsetV";
		*/
		
		//pupilSize for rotation Eye with blendShape
		connecFacialDriver 0 0 3 1 "Eye_BoxL_Ctrl.pupilSize" "blendShape2.pupil_big_L";
		connecFacialDriver 0 0 -3 1 "Eye_BoxL_Ctrl.pupilSize" "blendShape2.pupil_small_L";
		connecFacialDriver 0 0 3 1 "Eye_BoxR_Ctrl.pupilSize" "blendShape2.pupil_big_R";
		connecFacialDriver 0 0 -3 1 "Eye_BoxR_Ctrl.pupilSize" "blendShape2.pupil_small_R";

		connecFacialDriver 0 0 3 1 "Eye_BoxL_Ctrl.pupilScaleY" "blendShape2.pupil_bigY_L";
		connecFacialDriver 0 0 -3 1 "Eye_BoxL_Ctrl.pupilScaleY" "blendShape2.pupil_smallY_L";
		connecFacialDriver 0 0 3 1 "Eye_BoxR_Ctrl.pupilScaleY" "blendShape2.pupil_bigY_R";
		connecFacialDriver 0 0 -3 1 "Eye_BoxR_Ctrl.pupilScaleY" "blendShape2.pupil_smallY_R";


	}

	// tongue connect
	if ( $type == "tongue" ){
	connecFacialDriver 0 0 3 45 "Tongue_Move_Box_Ctrl.ty" "cc_tongue1.rz";
	connecFacialDriver 0 0 -3 -45 "Tongue_Move_Box_Ctrl.ty"  "cc_tongue1.rz";
	connecFacialDriver 0 0 3 45 "Tongue_Move_Box_Ctrl.ty" "cc_tongue2.rz";
	connecFacialDriver 0 0 -3 -45 "Tongue_Move_Box_Ctrl.ty"  "cc_tongue2.rz";

	connecFacialDriver 0 0 3 40 "Tongue_Move_Box_Ctrl.tx" "cc_tongue1.ry";
	connecFacialDriver 0 0 -3 -40 "Tongue_Move_Box_Ctrl.tx"  "cc_tongue1.ry";
	connecFacialDriver 0 0 3 40 "Tongue_Move_Box_Ctrl.tx" "cc_tongue2.ry";
	connecFacialDriver 0 0 -3 -40 "Tongue_Move_Box_Ctrl.tx"  "cc_tongue2.ry";

	connecFacialDriver 0 0 3 .2 "Tongue_Move_Box_Ctrl.length" "cc_tongue1.tx";
	connecFacialDriver 0 0 3 .2 "Tongue_Move_Box_Ctrl.length" "cc_tongue2.tx";
	connecFacialDriver 0 0 1 8 "Tongue_Move_Box_Ctrl.length" "cc_tongue.rz";

	}

}


//make correct Shape
global proc makeCorrectShape(string $targetGrp , string $shapeL , string $shapeR , string $jaw , string $name , int $offset ){
	if ( `objExists $shapeL` && `objExists $shapeR`  && `objExists $jaw` ) {
				
		string $dupMesh[] = `duplicate -rr -renameChildren -n "tempGRP" $targetGrp`;
		xform -r -t $offset 0 0 $dupMesh[0];
		string $BSNode[] = `blendShape -foc $shapeL $shapeR $jaw $dupMesh[0]`;
		setAttr ($BSNode[0] + "." + $shapeL) 1;
		setAttr ($BSNode[0] + "." + $shapeR) 1;
		setAttr ($BSNode[0] + "." + $jaw) 1;
		duplicate -rr -renameChildren -n ("correct_"+$name) $dupMesh[0];
		delete $dupMesh[0];	
	}
}

global proc b1CorrectShapeCMD () {
        
    string $target[] = `ls -sl -head 1`;
    
    makeCorrectShape $target[0] "mouth_smile_L" "mouth_smile_R" "jaw_open_M" "smile" 1.5;
    makeCorrectShape $target[0] "mouth_smileOpen_L" "mouth_smileOpen_R" "jaw_open_M" "smileOpen" 3;
    makeCorrectShape $target[0] "mouth_smileBig_L" "mouth_smileBig_R" "jaw_open_M" "smileBig" 4.5;
    makeCorrectShape $target[0] "mouth_angry_L" "mouth_angry_R" "jaw_open_M" "angry" 6;
    makeCorrectShape $target[0] "mouth_angryBig_L" "mouth_angryBig_R" "jaw_open_M" "angryBig" 7.5;
}

global proc makeFixShape( string $targetGrp , string $shapeL , string $shapeR , string $jaw , string $name , int $offset ){
		
	string $corShape = ("correct_"+$name);	
	if ( `objExists $corShape` ) {
		
		string $dupMesh[] = `duplicate -rr -renameChildren -n "tempGRP" $targetGrp`;
		xform -r -t $offset 0 0 $dupMesh[0];
		
		string $BSNode[] = `blendShape -foc $shapeL $shapeR $jaw $corShape $dupMesh[0]`;
		setAttr ($BSNode[0] + "." + $shapeL) -1;
		setAttr ($BSNode[0] + "." + $shapeR) -1;
		setAttr ($BSNode[0] + "." + $jaw) -1;
		setAttr ($BSNode[0] + "." + $corShape) 1;
		
		duplicate -rr -renameChildren -n ("fix_"+$name) $dupMesh[0];
		delete $dupMesh[0];		
	}
	
}

global proc b1FixShapeCMD () {
        
    string $target[] = `ls -sl -head 1`;
    
    makeFixShape $target[0] "mouth_smile_L" "mouth_smile_R" "jaw_open_M" "smile" 1.5;
    makeFixShape $target[0] "mouth_smileOpen_L" "mouth_smileOpen_R" "jaw_open_M" "smileOpen" 3;
    makeFixShape $target[0] "mouth_smileBig_L" "mouth_smileBig_R" "jaw_open_M" "smileBig" 4.5;
    makeFixShape $target[0] "mouth_angry_L" "mouth_angry_R" "jaw_open_M" "angry" 6;
    makeFixShape $target[0] "mouth_angryBig_L" "mouth_angryBig_R" "jaw_open_M" "angryBig" 7.5;
}

  
global proc b1unLock (string $node) {
	string $attr[] = `listAttr -l $node`;
	for ( $curAttr in $attr ) {	
			setAttr -l 0 ($node+ "." + $curAttr);
			print ( "*** unlock " + $node+$curAttr + "\n");			
	}
}

global proc b1unlockCmd () {
	string $sel[] = `ls -sl -head 1`;
	string $unlockList[] = `listRelatives -ad -c -type "transform" $sel[0]`;
	$unlockList[size($unlockList)] = $sel[0];
	for ($curMesh in $unlockList)
		b1unLock $curMesh;
}


//nCloth shader assign
global proc assignNclShader( string $type ){
    
    string $listNcl[] = `ls -typ $type`;
    
    for  ( $curNcl in $listNcl ) {
            
    string $temp[];
        
    $temp = `listConnections -s 1 -t "mesh" ($curNcl + ".inputMesh")`;
    string $curShape = $temp[0];
    
    tokenize $curShape "_" $temp;
    string $name = $temp[1];
    
    string $setRan = `shadingNode -n ("setRange_" + $name) -asUtility setRange`;
    
    
    
    string $curshader = `shadingNode -n ("lambert_" + $name) -asShader lambert`;
    string $curSG = `sets -renderable true -noSurfaceShader true -empty -name ("lambert_" + $name + "SG")`;
    connectAttr -f ($curshader + ".outColor") ($curSG + ".surfaceShader");
     
     
     if ( $type == "nRigid" ) { 
        setAttr ($setRan + ".oldMinY") 0;
        setAttr ($setRan + ".oldMaxY") 1;
        setAttr ($setRan + ".minY") 1;
        setAttr ($setRan + ".maxY") 0;       
        
        connectAttr -f ($curNcl+".collide") ($setRan +".valueY");
        connectAttr -f ($setRan +".outValue") ($curshader + ".color");
    } else if ( $type == "nCloth" ) { 
    
        setAttr ($setRan + ".valueX") 1;
        setAttr ($setRan + ".oldMinX") 0;
        setAttr ($setRan + ".oldMaxX") 1;
        setAttr ($setRan + ".minX") 0;
        setAttr ($setRan + ".maxX") 1;  
             
        setAttr ($setRan + ".oldMinY") 0;
        setAttr ($setRan + ".oldMaxY") 1;
        setAttr ($setRan + ".minY") .5;
        setAttr ($setRan + ".maxY") 1; 
        
        setAttr ($setRan + ".valueZ") 1;
        setAttr ($setRan + ".oldMinZ") 0;
        setAttr ($setRan + ".oldMaxZ") 1;
        setAttr ($setRan + ".minZ") 0;
        setAttr ($setRan + ".maxZ") 0;        
        
        connectAttr -f ($curNcl+".isDynamic") ($setRan +".valueY");
        connectAttr -f ($setRan +".outValue") ($curshader + ".color");
    }
    
    sets -edit -forceElement $curSG $curShape;
    
    }

}

//make sine add to hair chain control
global proc addSineWave(){
string $sel[] = `ls -sl`;
string $tokenTemp[];
tokenize $sel[0] "_" $tokenTemp;
string $pre = $tokenTemp[0];

string $line5 = ($pre + "_Line5_Bake_Con");

select ($pre + "_Line_curve");
string $sine[] = `nonLinear -n ($pre + "_sine") -type sine -lowBound 0 -highBound 2 -amplitude .5 -wavelength 1.3 -dropoff -1 -offset 0`;


addAttr -ln "_______________________" -at "enum" -en "wave:"  $line5;
setAttr -e -channelBox true ($line5 + "." + "_______________________");

addAttr -ln "waveOn" -keyable true -at double  -min 0 -max 1 -dv 1 $line5;
addAttr -ln "waveSize" -keyable true -at double -min -5 -max 5 -dv .5 $line5;
addAttr -ln "waveSpeed" -keyable true -at double  $line5;
addAttr -ln "waveVis" -keyable true -at bool -dv 1 $line5;


connectAttr -f ($line5 + ".waveOn") ($sine[0] + ".envelope"); 
connectAttr -f ($line5 + ".waveSize") ($sine[0] + ".amplitude");
connectAttr -f ($line5 + ".waveSpeed") ($sine[0] + ".offset");
connectAttr -f ($line5 + ".waveVis") ($sine[1] + ".v");

parent $sine[1] $line5;
setAttr ($sine[0] + ".rotateX") -90;
}


// UI 관련
global proc importDynamicChainCMD() {
	string $path = `textFieldButtonGrp -q -text BHCtxfPath`;
	string $name = `textFieldButtonGrp -q -text BHCtxfImport`;
	
	setupDynamicChain $name $path;

}

global proc copyHairSkinCMD() {
	// 컨트롤러 선택 후에 헤어mesh 선택.
	string $selectList[] =`ls -sl`;
	string $temp[];
	tokenize $selectList[0] "_" $temp;
	string $sourceMesh = ($temp[0] + "_hairSkinMesh");
	if ( `objExists $sourceMesh` ) {
		select -r $sourceMesh;
		select -add $selectList[1];
		skinCopyWithSkin;	
	}
	
	print "copyHairSkinCMD";
}

global proc setHairBakeCMD() {
	
	string $selection[] =`ls -sl`;
	for ($curSel in $selection) {
		select $curSel;
		setHairBake;
	}

}

global proc B1getSelection(string $UI) {
	string $sel[] = `ls -sl`;
	
	string $selections = stringArrayToString($sel, " ");	
	
	textFieldButtonGrp -e -text $selections $UI;
}

global proc copyPartialSkinCopyCMD() {
	
	string $targetMesh = `textFieldButtonGrp -q -text BHCtxftarget`;
	copySkinFromPartialMesh $targetMesh;

}


// UI
global proc hairDynamicChainSetup() 
{
	if(`window -exists hairDynamicChainWin`)
		deleteUI hairDynamicChainWin;
	
	window  -width 500 -height 250
		-resizeToFitChildren 0
		-menuBar true
		-maximizeButton true
		-titleBar true
		-sizeable 1
		-menuBarVisible true
		-title "build hair dynamic chain"
		hairDynamicChainWin;
	
	columnLayout -cal center BHCColMain;
	
	
	
// frame -  facial
	frameLayout -collapsable true -collapse 0  -enable 1 -label "facial setup " -borderStyle "in" -w 500 BHCframeFacial;	
	
	rowColumnLayout -nc 4 -cw 1 120 -cw 2 120 -cw 3 120 -cw 4 140
		-cat 1 left 10 -cat 2 left 10 -cat 3 left 10 -cat 4 left 10 BHCRowColFaca;
		
		columnLayout BHCColFacaa;
		text -l "	[ joint setup ] ";
		separator -h 10 ;	
		button -l " cc mirror" -w 100 -c "b1mirrorfacialCC;";
		separator -h 10 ;	
		button -l " joint mirror " -w 100 -c "b1mirrorJointPositioin";
		separator -h 10 ;
		setParent BHCRowColFaca;	
		
		columnLayout BHCColFacab;
		text -l "	[ tool ] ";
		separator -h 10 ;	
		button -l " abSymmetry " -w 100 -c "source \"N:/b1Env/maya/2014/scripts/b1Rigging/abSymMesh.mel\";abSymMesh;";
		separator -h 10 ;			
		button -l " rename " -w 100 -c "source \"N:/b1Env/maya/2012/scripts/renameAdvanced.mel\"";
		separator -h 10 ;			
		
		text -l "  [ cluster ] ";
		separator -h 10 ;	
		button -l " mirror clustor" -w 100 -c "b1mirrorCenterCluster;";
		separator -h 10 ;	
		
		
		
		setParent BHCRowColFaca;	
		
		columnLayout BHCColFacac;
		text -l "  [ connect ] ";
		separator -h 10 ;
		button -l " connect basic" -w 100 -c "b1connectFacialControl basic ;";
		separator -h 10 ;
		button -l " connect fix" -w 100 -c "b1connectFacialControl fix ;";
		separator -h 10 ;
		button -l " connect eyeAim" -w 100 -c "b1connectFacialControl eyeAim ;";
		separator -h 10 ;
		button -l " connect BallEye" -w 100 -c "b1connectFacialControl BallEye ;";
		separator -h 10 ;
		button -l " connect pupil" -w 100 -c "b1connectFacialControl pupil ;";
		separator -h 10 ;
		button -l " connect tongue" -w 100 -c "b1connectFacialControl tongue ;";
		separator -h 10 ;
			
		setParent BHCRowColFaca;	
		
		columnLayout BHCColFacad;
		text -l "  [ blend shape ] ";
		separator -h 10 ;	
		button -l " sort blendShape" -w 100 -c "sortBlendShape;";
		separator -h 10 ;	
		button -l " 차례로 blendShape" -w 100 -c "blendShapeGroup;";
		separator -h 10 ;		
		button -l " make BS targets" -w 100 -c "b1makeBStargetMesh;";
		separator -h 10 ;
		text -l "  [ correctShape ] ";
		separator -h 10 ;	
		button -l " correct Shape" 
		-ann " 기본 그룹 선택하고 실행. 해당하는 타겟이 있어야 실행됨."
		-w 100 -c "b1CorrectShapeCMD;";
		separator -h 10 ;	
		button -l " fix shape" 
		-ann " 기본 그룹 선택하고 실행. 해당하는 타겟이 있어야 실행됨."
		-w 100 -c "b1FixShapeCMD;";		
		
		setParent BHCRowColFaca;	
		
	setParent BHCframeFacial ;	
	
	setParent BHCColMain ;	
// frame -  facial
	

	
// frame -  rig01
	frameLayout -collapsable true -collapse 0  -enable 1 -label "rig 1 " -borderStyle "in" -w 500 BHCframeBS;	
	
	
	
	rowColumnLayout -nc 4 -cw 1 120 -cw 2 120 -cw 3 120 -cw 4 140
		-cat 1 left 10 -cat 2 left 10 -cat 3 left 10 -cat 4 left 10 BHCRowColBSa;
		
		columnLayout BHCColBSaa;
		text -l "	[ layer ] ";
		separator -h 10 ;	
		button -l " insert geoLayer" 
		-ann " geomety와 Geometry 하위의 모든 transform을 geoLayer에 넣어주고. SubControl과 연결해준다."
		-w 100 -c "b1InsetGeoLayer;";
		separator -h 10 ;	
		text -l "	[ group ] ";
		separator -h 10 ;	
		button -l " group same position" 
		-ann " 상위에 같은 위치의 zero grp을 만들어 줍니다. 한번에 여러개 가능."
		-w 100 -c "addZeroTransform;";
		separator -h 10 ;
		text -l "	[ lod02 ] ";			
		separator -h 10 ;
		button -l " assign lod02 tex" 
		-ann " lod02에 lambertShader 적용. material 선택하고 texture 선택한 뒤 실행."
		-w 100 -c "b1addlod02Tex;";
		
		separator -h 10 ;
		setParent BHCRowColBSa;	
		
		columnLayout BHCColBSab;
		text -l "	[ joint ] ";
		separator -h 10 ;	
		button -l " joint show" -w 100 -c "b1JointVisMaya2014 1;";
		separator -h 10 ;	
		button -l " joint hide" -w 100 -c "b1JointVisMaya2014 0;";
		separator -h 10 ;
		setParent BHCRowColBSa;	
		
		columnLayout BHCColBSac;
		text -l "  [ motion system ] ";
		separator -h 10 ;	
		button -l " motionSystem show" -w 100 -c "setAttr MotionSystem.visibility 1;";
		separator -h 10 ;	
		button -l " motionSystem hide" -w 100 -c "setAttr MotionSystem.visibility 0;";
		separator -h 10 ;	
		
		text -l "  	  [ pose ] ";
		separator -h 10 ;	
		button -w 100 -l "go Tpose" -c "b1goTpose 0 0;";
		separator -h 10 ;		
		button -w 100 -l "go skin pose" -c "b1goTpose 1 0;";	
		separator -h 10 ;
		button -w 100 -l "go default Pose" -c "b1goTpose 1 1;";
		separator -h 10 ;
		setParent BHCRowColBSa;	
		
		columnLayout BHCColBSad;
		text -l "  [ check ] ";
		separator -h 10 ;	
		button -l " delete Int Shape " 
		-ann " select한 그룹 하위에 있는 intermediate Shape을 모두 삭제한다.."
		-w 100 -c "deleteIntermediateMesh";
		separator -h 10 ;	
		button -l " unlock" 
		-ann " select한 그룹 하위에 있는 node들의 lock을 풀어준다."
		-w 100 -c "b1unlockCmd";
		separator -h 10 ;
		button -l " unique name" 
		-ann " 씬 안에 같은 이름을 쓰는 것들을 찾아내서 uniqSet에 넣습니다."
		-w 100 -c "b1checkUniqName;";
		separator -h 10 ;	
		button -l " check transform" 
		-ann " 선택된 것 하위에 transform이 freeze가 안되어 있는것들을 찾아내서 transfomeSet에 넣어줍니다."
		-w 100 -c "b1checkTransformFreeze;";
		separator -h 10 ;


		
		setParent BHCRowColBSa;	
		
	setParent BHCframeBS ;	
	
	setParent BHCColMain ;	
// frame -  rig01

// frame -  rig
	frameLayout -collapsable true -collapse 0  -enable 1 -label "rig 2" -borderStyle "in" -w 500 BHCframeRig;	
	
	rowColumnLayout -nc 4 -cw 1 120 -cw 2 120 -cw 3 120 -cw 4 140
		-cat 1 left 10 -cat 2 left 10 -cat 3 left 10 -cat 4 left 10 BHCRowColRiga;
		
		columnLayout BHCColRigaa;
		text -l "	[ build ] ";
		separator -h 10 ;	
		button -l " add ControlSet" -w 100 -c "if (`objExists \"ControlSet\"` ) {sets -add ControlSet;} else {sets -n ControlSet;} ";
		separator -h 10 ;	
		button -l " set build pose " -w 100 -c "b1setBuildPose";
		separator -h 10 ;
		button -l " go build pose " -w 100 -c "asGoToBuildPose bodySetup;" ;
		separator -h 10 ;
		setParent BHCRowColRiga;
		
		columnLayout BHCColRigab;
		text -l "	[ release ] ";
		separator -h 10 ;	
		button -l " delete all key " -w 100 -c "b1deleteAllKey";
		separator -h 10 ;	
		button -l " before release " -w 100 -c "b1beforeRelease";
		separator -h 10 ;
		
		button -l " lod03 export " -w 100 -c "b1ExportLod03FromRig";
		separator -h 10 ;
		
		
		setParent BHCRowColRiga;

		columnLayout BHCColRigac;
		text -l "	  [ skin ] ";
		separator -h 10 ;	
		button -l " copy skin weight " -w 100 -c "skinCopyWithSkin";
		separator -h 10 ;	
		
		setParent BHCRowColRiga;

		columnLayout BHCColRigad;
		text -l "	  [ ncloth ] ";
		separator -h 10 ;	
		button -l " shader assign " -w 100 -c "assignNclShader nCloth; assignNclShader nRigid;";
		separator -h 10 ;	
		
		setParent BHCRowColRiga;
		
		
		
		
		

	setParent BHCframeRig ;	
	
	setParent BHCColMain ;	
// frame -  rig	
	
// frame -  hair	
	frameLayout -collapsable true -collapse 0  -enable 1 -label " hair dynamic tool " -borderStyle "in" BHCframeHair;	
											
									
		string $defaultDir = "P:/1304_D40/D40_maya/scenes/rig/data/controller/";								
		textFieldButtonGrp  -label "chain rig path:" -text "" -cw3 80 350 100 -cat 1 right 10 	
		-buttonLabel " browse.. " 
		-bc ("BHCfileDialog \"BHCtxfPath\" \"" + $defaultDir + "\";" ) BHCtxfPath;
		
		
		string $defaultPath = "P:/1304_D40/D40_maya/scenes/rig/data/controller/dynChain_v03.mb";
		if (`optionVar -exists "IKchainPath"`)
			$defaultPath = `optionVar -q "IKchainPath"`;
			
		textFieldButtonGrp -e -text $defaultPath  BHCtxfPath;
		
		textFieldButtonGrp  -label "name:" -text "" -cw3 80 200 150 -cat 1 right 10 -cat 3 left 50 
		-buttonLabel "  		import 		 " -bc "importDynamicChainCMD" BHCtxfImport;

		rowColumnLayout -nc 4 -cw 1 120 -cw 2 120 -cw 3 250 
		-cat 1 left 10 -cat 2 left 10 -cat 3 left 10 BHCRowColAa;
		
		columnLayout BHCColAaa;
		text -l "	[ selection ] ";
		separator -h 10 ;	
		button -l "select ALL Root " -w 100 -c ("select \"*_Line_Con\"");
		separator -h 10 ;	
		button -l "select ALL Line5 " -w 100 -c ("select \"*_Line5_Bake_Con\"");
		separator -h 10 ;
		text -l "	  [ tool ] ";
		separator -h 10 ;	
		button -l "match Hair Chain " -w 100 -c "b1matchingHairChain 0 ";
		separator -h 10 ;
		button -l "		mirror X control	" 
		-ann " controller mirror할 때 사용합니다. 현재는 x축만 지원됩니다. 소스 먼저 선택하고 타겟 선택 후 실행."
		-w 100 -c "b1matchingHairChain 1 ";		
		separator -h 10 ;	
		setParent BHCRowColAa;

		
		columnLayout BHCColAab;
		text -l "	  [ tool ] ";
		separator -h 10 ;	
		

		button -l "		match bake	" -w 100 -c "setHairBakeCMD";
		separator -h 10 ;	
		button -l "		skin hair	" -w 100 -c "copyHairSkinCMD; repeatLast -ac copyHairSkinCMD";		
		separator -h 10 ;
		
		text -l "	  [ add ] ";
		separator -h 10 ;	
		
		button -l "		add sine control	" -w 100 -c "addSineWave";		
		separator -h 10 ;
		button -l "		add body follow	" 
		-ann " Zero에 constraint를 사용했을 경우 on/off 할 수 있는 attribute를 생성하고 연결합니다. Line5 선택하고 사용."
		-w 100 -c "connectBodyFollowCon";	
		separator -h 10 ;	
			
		button -l "	par cons batch	" 
		-ann " 한 부모에 여러 칠드런 동시에 parent constraint. 부모 선택 후 나머지 칠드런 선택후 실행."
		-w 100 -c "parentConsBatch";	
		separator -h 10 ;	


			
		setParent BHCRowColAa;	
		
		columnLayout BHCColAac;
			text -l "	[ skin copy ] ";
			separator -h 8 ;			
			textFieldButtonGrp  -label "targetMesh:" -text "" -cw3 80 100 80 -cat 1 right 5 	
			-buttonLabel "   add   " -bc "B1getSelection BHCtxftarget;" BHCtxftarget;
			
			rowColumnLayout -nc 2 -cw 1 120 -cw 2 120 
			-cat 1 left 10 -cat 2 left 10 BHCRowColAaca;
			
				columnLayout BHCColAacaa;
				separator -h 8 ;						
				button -l "		get joint list	" -w 100 -c "getJointList;";		
				
				setParent BHCRowColAaca;

				columnLayout BHCColAacab;
				separator -h 8 ;
				button -l "		partial skin copy	" -w 100 -c "copyPartialSkinCopyCMD; repeatLast -ac copyPartialSkinCopyCMD";		
				
				setParent BHCRowColAaca;
					
			setParent BHCColAac;
		
		setParent BHCRowColAa;
	setParent BHCframeHair;	
	setParent BHCColMain ;	
// frame -  hair End
		
	setParent .. ;	
	showWindow hairDynamicChainWin;

}
hairDynamicChainSetup;
